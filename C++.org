* enum
  enum 提供了创建符号常量的方式，可替代 const。
  在默认情况下，将整数值赋给枚举量，第一个枚举量的值是 0, 第二个枚举量的值是 1,
  依次类推。可通过显式地指定整数值来覆盖默认值。
  在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量。

  对于枚举，只定义了赋值操作符。
 
  枚举量是整型，可被提升为 int 类型，但 int 类型不能自动转换为枚举类型。

  枚举更常被用来定义相关的符号常量，而不是新类型。若只使用常量，而不创建枚举类型
  的变量，则可省略枚举类型的名称。

  可创建多个值相同的枚举量，如
  enum {zero, null=0, one, numero_uno = 1};

  枚举的取值范围:
  要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的 2 的幂，将它
  减去 1,得到的便是取值范围的上限。
  要计算下限，需要知道枚举量的最小值。若它不小于 0,则取值范围的下限是 0；否则，
  采用与寻找上限方式相同的方式(用绝对值)，但加上负号。

  选择多少空间来存储枚举由编译器决定。
* 计算机程序在存储数据时必须跟踪的 3 种基本属性
  1)信息存储在何处        (地址)
  2)存储的值为多少        (值)
  3)存储的信息是什么类型   (类型)
* 面向对象与面向过程在决策方面的区别
  OOP 与面向过程编程的区别在于，OOP 强调的是在 *运行阶段* (而不是 *编译阶段*) 进
  行决策。运行阶段决策就好比度假时，选择参观哪些景点取决于天气和当时的心情;而编
  译阶段决策更像不管在什么条件下，都坚持预先设定的日程安排。
  运行阶段决策提供了灵活性，可根据当时的情况进行调整。

* 内存泄漏 (memory leak)
  即已分配的内存无法再被使用。

* new/delete
** 使用原则
   1)不要使用 delete 来释放不是 new 分配的内存。
   2)不要使用 delete 释放同一个内存块两次。
   3)若使用 new [] 为数组分配内存，则应使用 delete [] 来释放。
   4)若使用 new [] 为一个实体分配内存，则应使用 delete (没有方括号) 来释放。
   5)对空指针应用 delete 是安全的。
** new
   使用 new 时，是在堆区分配了块内存，除非使用 delete 来释放这块区域，否则它一直
   存在，即使是在函数中使用 new 分配内存。
* 指针和数组基本等价的原因
  1) 指针算术和 C++ 内部处理数组的方式相同。如将整数变量加 1 后，其值将增加 1，
     但将指针变量加 1 后，增加的量等于它指向的类型的字节数。
* sizeof() 作用
** 作用在数组名时
   得到的是数组的总的字节数，而不是指针的字节数。
   若想获得数组名(是数组的头指针)的字节数，可用 (int *) arr_name 的形式，把数组
   名强制解释为指针。注意强制转换的类型为 int *，而不是其它的类型。
* 解除指针引用的方法
  法一: 使用 *p.
  法二: 若指针 p 是指向数组的指针，可把它当作数组名来用，如 p[1].
* 指针相减
  仅当两个指针指向同一个数组(也可指向超出结尾的一个位置)时，这种运算才有意义，将
  得到两个数组元素的位置间隔。
* 给 cout 提供一个字符的地址
  它将从该字符开始打印，直到遇到空字符为止。
  在 cout 和多数 C++ 表达式中，char 数组名、指向 char 的指针及用引号括起的字符串
  常量都被解释为字符串第一个字符的地址。

* 存储方式
** 自动存储
   局部变量。
** 静态存储
   包括全局变量和使用 static 修饰的变量.
** 动态存储
   即用 new 分配内存的变量，要配合 delete 来使用。

* 字符串
** Brief
   _字符串是以空字符为结尾的一系列字符_.
   字符串可用引号括起的字符串常量表示，其中隐式包含了结尾的空字符。
   可将字符串存储在 char 数组中，可用被初始化为指向字符串的 char 指针表示字符串。
   函数 strlen() 返回字符串的长度，其中不包括空字符。

   字符串字面值是常量，声明时一般对它的变量加上 const 修饰符。C++ 不能保证字符串
   字面值被唯一地存储，即，若在程序中多次使用了字符串字面值，则编译器可能存储该字
   符串的多个副本，也可能只存储一个副本。
** 字符串比较
   对于 C 风格字符串,用 <cstring> 头文件中的 strcmp() 函数来比较.对于 string 类
   型的字符串,则可直接通过 ==,>,< 等符号来比较,还可把 string 类型的字符串当作一
   般的字符数组来用,如
   string test = "flyer";
   cout test[3];
* cin 模拟 EOF
  若编程环境能够检测到 EOF,则在用户通过键盘模拟文件结尾 EOF 时,cin 将两位
  (eofbit 和 failbit) 都设置为 1.
  若检测到 EOF,则 cin.eof() 将返回 true,否则返回 false.
  若 eofbit 或 failbit 被置为 1,则 cin.fail() 成员函数返回 true,否则返回 false.
  更多的是应用 cin.fail() 来检测.
  在模拟 EOF 检测到结束后, cin 将不再起作用,若要继续输入,可通过 cin.clear() 来清
  除 EOF 标记,可使输入继续.
  
  在 Linux 下,用户按下 C-d 模拟 EOF;
  在 Windows 下,用户按下 C-z 模拟 EOF. 
