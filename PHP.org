* PDO
** PDO::prepare 和 PDO::execute
   在通过 prepare() 时， '?' 不能加任何引号。在 execute() 时，不能使用 SQL 的默
   认函数，这点儿在添加当前日期时尤其明显。若要添加日期，先通过 date() 函数建立
   一个指定格式的日期，然后加入到 execute() 语句中。
* stream_select()
  和 Linux 下的 select() 系统调用作用一样，看 PHP 手册时看不明白，通过 man
  select 更容易理解些。
  Linux 下 select() 原型:
  int select(int nfds, 
             fd_set *readfds, 
	     fd_set *writefds, 
	     fd_set *exceptfds,
	     struct timeval *timeout);
 
  对比 PHP 下的 stream_select() 原型:
  int stream_select(array &$read, 
                    array &$write, 
		    array &$except, 
		    int $tv_sec [, int $tv_usec = 0]);

  可知，我需要通过 select() 理解 stream_select() 的作用，$read、$write、$except
  和限定时间。

  select() allow a program to monitor multiple file descriptors, waiting until
  one or more of the file descriptors become "ready" for some class of I/O
  operation (e.g., input possible). A file descriptor is considered ready if it
  is possible to perform the corresponding I/O operation (e.g., read(2)) without
  blocking.
  
  Three independent sets of file descriptors are watched. Those listed in
  /readfds/ will be watched to see if characters become available for reading
  (more precisely, to see if a read will not block; in particular, a file
  descriptor is also ready on end-of-file), those in /writefds/ will be watched
  to see if a write will not block, and those in /exceptfds/ will be watched for
  exceptions. On exit, the sets are modified in place to indicate which file
  descriptors actually changed status. Each of the three file descriptors sets
  may be specified as *NULL* if no file descriptors are to be watched for the
  corresponding class of events.

  /timeout/ is an upper bound on the amount of time elapsed before select()
  returns. If both fields of the /timeval/ structure are zero, then select()
  returns immediatly.(This is useful for polling). If /timeout/ is *NULL* (no
  timeout), select() can block indefinitely.

  On success, select() returns the number of file descriptors contained in the
  three returned descriptor sets (that is, the total number of bits that are set
  in /readfds/, /writefds/, /exceptfds/) which may be zero if the timeout
  expires before anything interesting happends. On error, -1 is returned, an
  errno is set appropriately; the sets and timeout become undefined, so do not
  rely on their contents after an error.
* 设置报错
  最好每次写 PHP 时，都在开头使用
  error_reporing(E_ALL);
  来打印所有可能的出错信息。
* 使用时间时要注意的
  若在程序中需要使用时间，则需要在使用之前设置下时区，在国内一般用
  date_default_timezone_set("Asia/Chongqing");

* sleep() 使用时注意
  若是在多进程中使用 sleep(),如想在父进程 sleep() 一段时间，而子进程正常运行，这
  样 sleep() 可能会失效，因为子进程在退出时会向父进程发出一个信号，sleep() 可能
  在父进程接受到该信号时会退出，如下:

  <?php
  error_reporting(E_ALL);

  date_default_timezone_set("Asia/Chongqing");

  $pid = pcntl_fork();
  switch ($pid) {
  case 0:
  /* in child */
  echo "in child\n";
  exit(0);
  case -1:
  die("pcntl_fork() failed\n");
  default:
  /* in parent */
  echo "in parent\n";
  sleep(10);
  echo "after 10 seconds, parent wakes.\n";
  }

  在这个程序中，父进程不会 sleep 10 秒，会直接返回。可在子进程中运行一段代码，在
  子进程中 sleep()，这样或许可以避免 sleep() 被信号中断的问题。
  若必须使父进程 sleep 一段时间，则在 Unix 或类 Unix 平台下，使用系统提供的
  sleep 命令也可以实现。修改以上代码:

  <?php
  error_reporting(E_ALL);

  date_default_timezone_set("Asia/Chongqing");

  $pid = pcntl_fork();
  switch ($pid) {
  case 0:
  /* in child */
  echo "in child\n";
  exit(0);
  case -1:
  die("pcntl_fork() failed\n");
  default:
  /* in parent */
  echo "in parent\n";
  system("sleep 10");
  echo "after 10 seconds, parent wakes.\n";
  }
* 使用 PDO 后获得数据库查询的行数
  $sql_num         = "SELECT COUNT(*) FROM $table";
  $proxy_total_num = $dbh->query($sql_num)->fetchColumn();

* 打印文件、函数、行号、类名等信息
  可通过变量 __FILE__、__FUNCTION__、__LINE__、__CLASS__ 来获取。
* phpize
  有时使用 phpize 时可能会出现如下的错误:

  Cannot find build files at '/usr/local/lib/php/build'. Please check your PHP
  installation.

  找下 phpize 的位置，通过绝对路径来使用 phpize.
* php-config
  我在安装 xhprof 过程中遇到过因为 php-config 不能用的问题，通过
  $ lcoate php-config
  发现有两个位置含有 php-config 命令，试了试之后发现只有一个可以正确使用，于是把
  出现问题的那个删除了。
  在有问题的情况下，make 时会提示源码错误。以后在出现这种问题时，注意下
  php-config 是否能够正确使用。

  我按照 gearman 官网上的资料安装 gearman 的 php 扩展时，提示 zend_internal 之类
  的错误，也是因为 php-config 的问题，在 configure 时通过指定良好的 php-config
  可以解决这个问题:
  $ ./configure --with-php-config=/usr/bin/php-config
* 子进程被 kill 掉时文件锁的问题
  在子进程中对一个文件加上 LOCK_EX|LOCK_NB 锁，当子进程被其它进程通过
  posix_kill() 发出 SIGKILL 或 SIGTERM 信号后，被子进程加锁的文件不会自动解锁，
  除非是子进程自己退出。
* Web API
** 获取完整的参数数据
   以
   http://localhost/api.php?url=http://api.douban.com/test.php?arg1=242&arg2=24&follow=y
   其中 http://localhost/api.php 是 API，通过 $_GET['url'] 获得不了用户传入的完
   整的 url，只能获得用户传入的 url 的部分，如本例中的
   http://api.douban.com/test.php?arg1=242 之后的就获得不了。这是因为 url 中是以
   & 作为参数的分隔符。
   解决方法是，可用 $_SERVER['QUERY_STRING'] 来获得用户传入的所有参数，然后自己
   解析字符串。
