* 小知识
** 1、端口 
   端口扫描器是一种检测服务器或主机虚拟端口是开启或关闭的工具。
   端口允许同一台计算机上的不同应用程序同时共享网络资源。连接本地局域
   网或互联网的计算机运行着许多不同服务，它们监听着常用或不常用的端口。
   端口数的范围从0到65535,0到1023的端口数是常用，它们中有许多是为FTP、
   SSH、HTTP、telnet、DNS和NNTP等服务保留的，1024到49151端口是注册端
   口，49152到65535则分配给动态或私人端口。
** 2、linux 下 rc 的含义
   是 run command 的简写.
** 3、使用 man
   man 除了可以查系统命令和 C 函数的用法，还有很多功能，通过 man man
   可查看其中8个部分的用法：
   #1 User Commands
   #2 System Calls
   #3 C Library Functions
   #4 Devices and Special Files
   #5 File Formats and Conventions
   #6 Games et. Al.
   #7 Miscellanea
   #8 System Administration tools and Deamons
** 4、How do I figure out dependencies for Slackware packages?
   The truth is that you're no supposed to. The first time you logged
   into your new Slackware installation, you received an email
   explaining, among other things, Slackware's approach to package
   management:
   /Slackware is designed around the idea that the systme should be a/
   /complete installation kept updated with any official/
   /patches. This avoids the mess of dependencies that some other/
   /Linux based GNU System face./
** 5、我的分区信息
   sda1 Primary ntfs
   sda2 Primary ntfs
   sda4 Primary ext4
   sda5 Logical swap
   sda6 Logical ext4
   sda7 Logical btrfs
** 6、Environment variables
*** 1、Profile
   Environment variables are a set of dynamic named values that can
   affect the way running processes will behave on a computer. They
   can be said in some sense to create the operating environment in
   which a process runs. For example, an environment variable with a
   Standard name can store the location that a particular computer
   system uses to store temporary files——this may vary from one
   computer System to another. A process which invokes the environment
   variable by (standard) name can be sure that it is storing
   temporary information in a directory that exists and is expected to
   have sufficient space.
   In all Unix and Unix-like systems, each process has its own private
   set of environment variables. By default, when a process is created
   it inherits a duplicate environment of its parent process, except
   for explicit changes made by the parent when it creates the
   child. At API level, these changes must be done between *fork* and
   *exec* . Alternatively, from shells such as bash, you can change
   envirionment variables for a particular command invocation by
   indirectly invoking it via *env* or using the
   ENVIRONMENT_VARIABLE=VALUE <command> notation. All Unix operating
   system flavors, MS-DOS, and Microsoft Windows have envirionment
   variables; however, they do not all use the same variables
   names. Running programs can access the values of envirionment
   variables for configuration purposes. 
   Shell scripts and batch files use envirionment variables to
   communicate data and preferences to child processes. They can also
   be used to store temporary values for reference later in the
   script, although in Unix other variables are usually used for this.
   In Unix, an envirionment variables that is changed in a script or
   compiled program will only affect that process and possibly child
   processes. The parent process and any unrelated processes will not
   be affected. In MS-DOS changing or removing a variable's value
   inside a BATCH file will change the variable for the duration of
   command.com's existence.
   In Unix, the envirionment variables are normally initialized during
   system startup by the system init script, and hence inherited by
   all other processes in the system. Users can, and often do, augment
   them in the profile script for the shell they are using.
*** 2、Working principles of environment variables
    A few simple principles govern how environment variables BY
    INSTALLING, achieve their effect.
**** Local to process
     Environment variables are local to the process in which they were
     set. That means if we open two terminal windows (Two different
     processes running shell) and change value of envirionment
     variables in one window, that change will not be seen by other
     window.
**** Inheritance
     When a child process is created, it inherits all the environment
     variables and their values from the parent process. Usually, when
     a program calls another program, it first creates a child process
     by forking ,then the child adjusts the envirionment as needed and
     lastly the child replaces itself with the program to be
     called. This procedure gives the calling program control over the
     envirionment of the called program.
**** Case sensitive
     In Unix and Unix-like systems the names of envirionment variables
     are case sensitive.
**** Persistence
     Environment variables persistence can be session-wide or
     system-wide.
** 7、磁盘命名
   Linux 中使用 sdx 表示 SCSI 磁盘，x 表示 a、b..., hdx 表示 IDE 磁盘，x 表示 a、
   b...
** 8、安全
   Security is a process, not a state.
** 9、网络端口、协议文件
   /etc/services
   /etc/protocols
** 10、ip-forwarding
   允许把计算机当作路由器来使用，一般是计算机有两块网卡时可以开启这个选项，这样
   计算机就可起到路由器的作用。
** 11、Unicode Terminology
   *ASCII* : American Standard Code for Information Interchange
   *BMP* : Basic Multilingual Plane (plane 0)
   *BOM* : Byte Order Mark (character that denotes byte-ordering)
   *CJK* *CJKV* : Abbreviation for Chinese-Japanese-Korean (and -Vietnames)
   *Code point* : Similar to an ASCII value, represents any value in the Unicode
   codespace
   *Octet* : Ordered sequence of eight bits as a single unit, aka (8-bit) byte
   *UCS* : Universal Character Set
   *UCS2* : Universal Character Set coded in 2 octes (also see UTF-16)
   *UCS4* : Universal Character Set coded in 4 octets
   *UTF* : Unicode or UCS Transformation Format
   *UTF-8* : 8-bit UTF Transformation Format (unsigned byte sequence one to four
   bytes in length)
   *UTF-16* : 16-bit UFT Transformation Format (unsigned byte sequence usually
   one 16-bit word in length; also see UCS2)
** 12、line separators
   在 POSIX 系统 (Unix family or  MAC OS X)， 它是 '\n'
   在 DOS 和 Windows 系统中，它是 '\r\n'
   在老式的 MacOS 系统中，它是 'r'.
** 13、在 chrome 中浏览本地文件系统
   格式为:
   file://path
   其中 path 是绝对地址，如 /home/flyer
* 经典
** 1、About good article for IT
   No one likes to be told "you should use this", "you should use
   this", etc. In the end we all use what we discover is best suited
   for our needs. So a really good article should not take sides, it
   should only provide facts, so the user who reads it would get a
   fair impression of one software and the other, then the choice
   would be his, and honor would be ours.
** 2、创业建议
   柳传志建议创业者要想清楚三件事请：
   1）所做的事能不能赚到钱，能赚多少钱、什么时候赚钱;
   2）行业门槛有多高，进入门槛是什么，自身的水平能否达到行业标准;
   3）考虑清楚竞争对手的状况，因为竞争关乎生存。
** 3、自信
   1)你是要成为猎人，还是猎物？x0
* Network
** 1、添加 ipv6 nameserver
   在 /etc/resolv.conf 中添加 
   nameserver 2001:470:20::2
** 2、ipv6 vpn 上网
   先添加 ipv6 的 nameserver，然后输入 modprobe tun
   接着输入 openvpn /etc/openvpn/ipv6.ovpn
   即可.
** 3、wget 下载整个网站
   可使用下面的命令
   wget -r -p -k -np 网站地址
   -r 表示递归下载，会下载所有的链接，不过要注意的是，不要单独使用这个
   参数，因为若你要下载的网站也有别的网站的链接， wget 也会把别的网站
   的东西下载下来，故要加上 -np 这个参数，表示不下载别的站点的链接。
   -k 表示将下载的网页里的链接修改为本地链接。 -p 获得显示网页所需的元
   素，如图片等。
   还可使用以下参数：
   -c 表示端点续传
   -t 100 表示重试100次， -t 0 表示无穷次重试
   还可将要下载的 url 写到一个文件中，每个 url 一行，使用以下的命令
   wget -i download.txt
   --reject=avi,rmvb 表示不下载 avi、rmvb 文件，--accept=jpg,jpeg 表示
   只下载 jpg、jpeg 的文件。
** 4、vsftpd 架设 ftp 站点
*** 1、目录
   目录在 /home/ftp/ 中。要把其中的内容的属性的三个组中都添加 r,这样才
   能下载.虚拟化
*** 2、添加用户
    先添加组（若存在则可不填加），例：
    # groupadd ftpgroup
    修改 /etc/vsftpd.conf，设置
    chroot_list_enable=YES
    chroot_list_file=/etc/vsftpd.chroot_list
    然后在 /etv/vsftpd.chroot_list 中添加用户，每行一个用户，重新启动 vsftpd 服
    务即可。
** 5、设置 DNS
   网速慢时，可以试试这个 nameserver: 61.134.1.5
** 6、ssh
*** 1、简介
   传统的网络服务程序，如 ftp、POP、telnet，在本质上都是不安全的，因为
   它们在网络上用明文传送口令和数据，别有用心的人非常容易就可截获这些
   口令和数据。而且，这些服务程序的安全验证方式也是有其弱点的，就是容
   易受到“中间人”（man-in-the-middle）这种方式的攻击。所有“中间人”
   的攻击方式，就是“中间人”冒充真正的服务器接收你传给服务器的数据，
   然后再冒充你把数据传给真正的服务器。服务器和你之间的数据传送被“中
   间人”一转手做了手脚之后，就会出现严重的问题。
   通过使用 SSH，可把所有传输的数据进行加密，这样“中间人”这种攻击方
   式就不能实现了，且能够防止 DNS 和 IP 欺骗。还有一个额外的好处是传输
   的数据是几个能过压缩的，所以可加快传输的速度。 
*** 2、ssh 的工作机制
    ssh 分为两部分：客户端部分和服务端部分。
    服务端是一个守护进程（daemon），它在后台运行并响应来自客户端的连接
    请求。服务器端一般是 sshd 进程，提供了对远程连接的处理，一般包括公
    共密钥认证、密钥交换、对称密钥加密和非安全连接。
    客户端包括 ssh 程序及像 scp （远程拷贝）、slogin （远程登录）、
    sftp （安全文件传输）等其他的应用程序。
    它们额工作机制大致是本地的客户端发送一个连接请求到远程的服务端，服
    务端检查申请的包和 IP 地址再发送密钥给 ssh 的客户端，本地再将密钥
    发回给服务端，自此连接建立。
    ssh 被设计成为工作于自己的基础之上而不利用超级服务器（inetd），虽
    然可通过 inetd 的 tcpd 来运行 ssh 进程，但这完全没必要。启动 ssh
    服务器后，sshd 运行起来并在默认的 22 端口进行监听。若不是通过
    inetd 启动的 ssh，那么 ssh 就将一直等待连接请求。当请求到来的时候，
    ssh 守护进程会产生一个子进程，该子进程进行这次的连接处理。
    OpenSSH 是 SSH 的替代软件，且免费。
*** 3、使用
    可用 ssh-keygen 命令来生成密钥对，把它保存在自己和远程机器的
    ~/.ssh/ 目录下。并保证权限为 rw.然后通过 
    $ ssh ip地址 
    或 
    $ ssh 域名
    即可访问远程机器。
    也可通过如下方式建立连接：
    $ ssh 远程主机名@ip
    若想把本机某文件，如本例中 ~/flyer.txt 复制到远程主机中，可用
    $ scp /home/flyer/flyer.txt  远程主机名@ip:目标目录
    若想把远程主机上的某文件，如 test.txt 复制到本机中，可用
    $ scp 远程主机名@ip:/home/用户名/tets.txt /home/flyer 
    若想复制整个文件夹，加个参数 -r 即可。
    Windows 下可用 SecureCRT 来实现 ssh 。
** 7、查看域名 ip
   可通过 nslookup 或 dig 或 host  命令。
** 8、查看本机所有网卡信息 
   # ifconfig -a
** 9、IP 地址分类
   A    0.0.0.0~127.255.255.255
   B    128.0.0.0~191.255.255.255
   C    192.0.0.0~223.255.255.255
   D    224.0.0.0~239.255.255.255
   E(未分配) 240.0.0.0~255.255.255.255
   D 类地址通常用于广播，E 类地址未分配使用。
** 10、特殊的 IP 地址
*** 1、网络地址 0
    在 A 类地址中，网络地址 0 是不可路由的地址部分。当作源地址时，唯一
    合法的使用是在初始化时主机用来动态地得到由服务器分配给自己的 IP 地
    址。当用作目的地址时，只由地址 0.0.0.0 有意义，且只能用于本地机器
    标识自己或作为惯例指示默认的路由。
*** 2、回环网络地址 127
    A 类地址中，网络地址 127 是不可路由的地址部分。回环地址是 OS 支持
    的专用网络接口。它用于本地网络服务的地址分配机制。换句话说，本地用
    户用它来标识本地服务器。回环流量完全保持在 OS 内，而不会被送到物理
    的网络接口。代表性地，127.0.0.1 作为唯一的回环接口指向本地主机。
*** 3、广播地址
    广播地址应用于网络内所有主机。广播地址主要有两类， *有限广播* 不被
    路由但会被送到相同物理网络段上的所有主机。IP 地址的网络字段和主机
    字段全为 1 就是地址 255.255.255.255. *直接网络广播* 会被路由，并被
    送到专门网络上的每台主机，IP 地址的网络字段定义这个网络。主机字段
    通常全为 1, 如 192.168.10.255. 另外，有时会作为网络的地址，如
    192.168.10.0。
** 11、子网划分
   每类网络都有默认的子网掩码来指示给定地址的网络字段和主机字段的划分。
   A~C 类地址默认的子网掩码
   A    255.0.0.0
   B    255.255.0.0
   C    255.255.255.0
   为什么子网划分很重要？简单来讲，子网定义了给定网络的最大广播空间。
   在给定子网中，一台主机可向其他所有主机发出广播。然而，在实际应用中，
   广播更多地受到物理性的限制而不是由子网掩码所实现的逻辑性限制。将众
   多的设备连接到交换机后，可能出现性能下降，最好能将网络划分成更小的
   逻辑单元。不进行子网划分的话，地址空间会很大、很平坦，这会使网络速
   度和现在相比要慢很多。
   常用 /NN 来标记子网， /NN 表示地址中网络字段所占的位数。
** 12、IP 数据报分段
   分段处理在 OSI 的 IP 层，且对高层协议（如 TCP 和 UDP）是透明的。
** 13、ARP 协议
   Address Resolution Protocol 是用于连接网卡之类的物理设备和 IP 地址
   的协议。网络设备使用 48 位的地址（即 MAC 地址），这个地址在给定网段
   的所有设备中是独一无二的。它使用广播来确定给定子网中 IP 地址的 MAC
   地址。
   MAC 地址不会穿过网络进行端对端的传输，只会在邻接的网络接口间或主机
   和路由器之间传递，它们不会被路由出去。
** 14、服务端口
   服务端口能标识程序和正在发生的单个会话或连接。服务端口使用数字化名
   称，用于不同的基于网络的服务，它们也用作两个程序间特定连接端点的数
   字化标识。服务端口号范围从 0~65535.
   服务器程序（即后台守护程序 daemon）在分配给它们的服务端口上监听入站
   连接。
   依据惯例，主要的网络服务端口是分配在 1~1023 低范围内、众所周
   知的或著名的端口。这些端口号到服务器的映射是由 IANA（Internet
   Assigned Numbers Authority）作为一组普遍认可的约定或标准集来管理。
   一个公共服务是可简单地通过 Internet 从所分配的端口上获得的服务。若
   你的机器没有提供特定的服务，但有人试图连接到分配给那个服务的端口，
   则什么事情也不会发生。
   从 1024~65535 的高位端口被称为非特权端口(unprivileged port)。它们服
   务于双重目的。最主要原因是这些端口被动态地分配给连接的客户机端。客
   户机和服务端口对的组合，再加上它们各自的 IP 主机地址，唯一地标识了
   一个连接。
   此外，在 1024~49151 范围内的端口是在 IANA 那里注册了的。这些端口能
   用作通用非特权缓冲池的一部分，它们还与诸如 SOCKS 或 X Window 服务器
   等特别服务相联系。最初的想法是在高端口提供的服务不以 root 权限运行。
   它们是由用户级、非特权程序使用的。在个别情况下这种约定也许被遵守，
   也许不被遵守。
   常用服务端口可在 /etc/services 中找到。
   端口号是与协议相关的。 
** 15、A、B、C 类专用 IP 地址
   A、B、C 类范围内的这三个专用地址集是专门局域网内使用而保留的，这些
   地址并未打算在 Internet 上使用。同样，这些地址不需购买已注册的 IP
   地址就可在任何站点内部使用。
   A 类专用地址范围： 10.0.0.0~10.255.255.255
   B 类专用地址范围： 172.16.0.0~172.31.255.255
   C 类专用地址范围： 192.168.0.0~192.168.255.255
** 16、D 类多播 IP 地址
   D 类地址范围内的 IP 地址是预留作为多点投递网络广播的目的地址的，如
   音频广播或视频广播的目的地址。
** 17、本地链路网络地址
   当 DHCP 客户机不能从服务器获得地址时，它们会为自己分配一个本地链路
   地址，这些地址范围是 169.254.0.0~169.254.255.255
** 18、网络测试(TEST-NET)地址
   192.0.2.0~192.0.2.255 的地址空间是为测试网络而保留的。
** 19、刺探(probe)和扫描(scan) 
   刺探(probe) 是企图连接到一个单独的服务端口或获得该端口的响应。
   扫描(scan) 是到一个不同服务端口的集合的一系列的刺探。扫描常自动进行。
* 虚拟技术
* 计算机启动过程
** Lilo 和 Grub
*** 优缺点
    *Advantage* to Lilo:
    1)Easy to add a boot screen
    2)Slackware setup can install automatically
    3)Lilo can works in almost every scenario.
    4)Lilo is simple/stupid and doesn't need to know the partitioning
    scheme or filesystem.
    *Disadvantages* to Lilo:
    1)Changes boot block on every configuration change
    2)May not install on some fake RAID
    3)Configuration update needed for kernel change
    4)Lilo has a 15 character limitation in titles. On a system with
    only one OS that likely is not a problem. With multi-boot systems,
    or with multiple kernels for one system in testing, that
    limitation is mildly frustrating.
    
    *Advantage* to Grub 0.97(legacy)
    1)Can install using "native" BIOS only boot floopy or CD
    2)Works with Fake RAID or other BIOS dependent installation
    3)Boot block not altered on configuration changes
    4)No configuration update needed for kernel change
    *Disadvantages* to Grub 0.97(legacy)
    1)Difficult to add a boot screen
    2)Not automatically installed by Slackware setup
    3)Couldn't boot on some motherboards when the partitions don't
    follow dos compatibility.

    Grub 2(not the legacy version) is more complicated than Grub
    legacy and also suffers from some of the limitations of
    Lilo. However, Grub2 supports some additional features that may be
    needed on some hardware.
* /dev/shm
** 1、介绍
   /dev/shm is just another branch in the file system. Useless unless
   something is stored there.
   The name shm is an acronym for shared memory. Typically /dev/shm is
   used with *tmpfs* file system. Typically a tmpfs location is
   created and mounted in /etc/fstab.
   By design, tmpfs uses only up to 1/2 of the avaiable RAM, but that
   can be modified by mount options. Typical usage is far less than
   1/2.
   Anything stored in tmpfs is lost upon a reboot or shutdown, which
   for many people is a convenient way of controlling garbage files
   from accumulatin. 
   tmpfs can be of more use when the envirionment variables $TMP,
   $TEMP, and $TMPDIR are assigned to a tmpfs location.
   Once in a blue moon that might not be helpful such as when building
   packages that require an abnormal amount of build space. The
   solution then is to ensure the build script does not use tmpfs.
   Any program linked with a recent version of glibc that uses the
   POSIX shared memory API (shm_open and related functions) will use
   /dev/shm. Those programs are not very common but, as you may not be
   sure which ones could need it, /dev/shm should be configured
   properly.
   通过查看 /etc/fstab，可发现在我的系统中，tmpfs 被自动挂载到
   /dev/shm 上。
   tmpfs is also known as the virtual memory(VM) filesystem. tmpfs is
   like a ramdisk, but differetn. Like a ramdisk ,tmpfs can use your
   RAM, but it can also use your swap devices for storage. And while a
   traditional ramdisk is a block devices and requires a *mkfs*
   command of some kind before you can actually use it, tmpfs is a
   filesystem, not a blcok device; you just mount it, and it's there.
   The linux kernel's virtual memory resources come frm both your RAM
   and swap devices. The VM subsystem in the kernel allocate these
   resources to other parts of the System and takes care of managing
   these resources behind-the-scenes, often transparently moving RAM
   pages to swap and vice-versa.
   The tmpfs filesystem requests pages from the VM subsystem to store
   files. tmpfs doesn't know whether these pages are on swap or in
   RAM; it's the VM subsystem's job to make those kinds of
   decisions. All the tmpfs filesystem knows is that it is using some
   form of virtual memory.
   Unlike most "normal" filesystems, like ext2, XFS, ReiserFS and
   friends, tmpfs does not exist on top of an underlying block
   device. Because tmpfs sits on top of VM directly, you can create a
   tmpfs filesystem with a simple mount command:
   # mount tmpfs /mnt/ -t tmpfs
   Standard linux ramdisks are block devices, so they must be
   formatted with a filesystem of your choice before you can use
   them. In contrast, tmpfs is a filesystem. So you can just mount it
   and go.
** 2、tmpfs advantage
    *Dynamic filesystem size*
    /dev/shm (where the tmpfs is mounted on) will initially have a
    very small capacity, but as files are copied and created, the
    tmpfs filesystem driver will allocate more VM and will dynamically
    increase the filesystem capacity as needed. And, as files are
    removed from /dev/shm, the tmpfs filesystem driver will
    dynamically shrink the size of the filesystem and free VM
    resoures, and by doing so return VM into circulation so that it
    can be used by other parts of the System as needed.
    *Speed*
    The other major benefit of tmpfs is its blazing speed.
    *No persistence*
    tmpfs data is not preservered between reboots, because virtual
    memory is volatile in nature. It makes tmpfs an excellent
    filesystem for holding data that you don't need to keep, such as
    temporary files (those found in /tmp) and parts of the /var
    filesystem tree.
** 3、Using tmpfs
    想在自动挂载时限制 tmpfs 的大小，可在 /etc/fstab 中添加如下语句：
    tmpfs /dev/shm tmpfs size=32m 0 0
    或在挂载时用如下格式：
    # mount tmpfs /tmp -t tmpfs -o size=64m
** 4、etc
    Actually, things do use /dev/shm. If you're using Firefox, MySQL,
    PostgreSQL, Oracle (pretty much any RDBMS), it's used for POSIX
    IPC.
    We can use the following command to see the result:
    $ ipcs
    System V IPC mechanisms (shared memory, message queues and
    semaphores) do not use /dev/shm. That belongs to a different API.
    Shared memory objects use 32-bit binary integer names, not
    alpha-numeric names.
    POSIX shared memory objects are implemented on Linux using a tmpfs
    filesystem mounted at /dev/shm. This is a minimal expection and
    not a restrictive specification. Nothing in such a statement says
    that other tmpfs tasks can't use /dev/shm.
    Originally /dev/shm was intended as a knowable mount point for
    shared memory segments. tmpfs is a file system that exists in RAM
    for storing volatile non-persistent data. Similar but not the
    same.
    /dev/shm must exist for those apps expecting to support shared
    memory segments.
    A filesystem is a filesystem. Once created that system can be used
    to store files.
    /tmp is listed in FHS to be used for non-persistent temporary
    files. /var/tmp is listed in FHS to be used for
    persistent-temporary files. 
    Consider that the default in most Slackware build scripts is to
    perform all operations in /tmp. Every file created in that build
    process except that the final package would be considered
    non-persistent. Yet many build scripts do not delete those
    files. Many distros are designed to clean /tmp every 10 days or
    so. The stock Slackware does not do that. The result is /tmp is
    being used for persistent storage rather than non-persistent. 
* LILO
  与它相关的配置程序是 lilo 和 liloconfig ，配置文件是 /etc/lilo.conf ，可通过 
  $ man 5 lilo.conf
  来查看 lilo.conf 的参数说明.
  LILO reads its settings from the */etc/lilo.conf(5)* file. It is not read each
  time you boot up, but instead is read each time you install LILO. LILO must be
  reinstalled to the boot sector each time you make a configuration change. Many
  LILO errors come from making changes to the *lilo.conf* file, but failing to
  re-run lilo to install these changes. *liloconfig* will help you build the
  configuration file so that you can install LILO for your system. If you prefer
  to edit */etc/lilo.conf* by hand, then reinstalling LILO just involves typing
  */sbin/lilo* at the prompt.
  使用 *liloconfig* 配置 lilo 过程中，可以设置 framebuffer.
* Tex
** 1、中文输入
   先挂载上 texlive 镜像，然后执行
   $ sudo tlmgr install xecjk ctex
   安装好后，接着找系统中安装过的字体
   $ fc-list :lang=zh-cn
   如下是个模板：
   \documentclass{article}
   \usepackage{xeCJK}
   \setCJKmainfont{KaiTi_GB2312}
   \begin{document}
   \end{document}
   把 KaiTi_GB2312 改为自己系统中的字体即可。

** 2、常见特殊字符
   # $ % ^ & _ { } ~ \
   若使用这些字符的表面含义，使用 \ 转义即可.但 \ 不能被转义，因为 \\
   表示换行,可用 \backslash 来生成。
** 3、Latex 命令
   它对大小写敏感，有两种格式：
   1）以一个反斜杠 \ 开始，命令名只由字母组成。命令名后的空格符、数字
   或任何非字母的字符都标志着该命令的结束。
   2）由一个反斜杠和非字母的字符组成。
   LaTex 忽略命令之后的空白字符。若希望在命令之后加空格，在可命令后加
   上 {} 和一个空格，或一个特殊的空格命令。
   有些命令需要一个参数，该参数用花括号 {} 括住并写在命令的后面。一些
   命令支持可选参数，可选参数可用方括号 [] 括住，然后写在命令后面。
** 4、常用命令及符号
   \\ 或 \newline    另起一行，但不另起一段
   \\*    强制断行后，还禁止分页
   \newpage    另起一页
   \textsl{}    括号中的字用斜体输出
   \backslash    斜杠
   \hyphenation{word list} 使列于参量中的单词仅在注有“-”的地方断词，
   命令的参量仅由正常字母够成的单词，或由 LaTex 视为正常字母的符号组成。
   \mbox{text}    保证把几个单词排在同一行，在任何情况下，这个命令把它
   的参量排在一起。
   \fbox{text}    与 \mbox 类似，还能围绕内容画一个框
   \emph{text}    对 text 进行强调，与前后的单词的字体格式不同来强调
   \frenchspacing    禁止在句号后插入额外的空白，可单独把这条命令放在
                     文档前，则命令 \@ 就不必要了
   \@    用在 . 后跟大写字母的情况下，在 . 前使用这个命令，表示这是句
         子的结尾,需要在 . 和后面的大写字母前插入额外的空白

   \today    输出如 November 18,2007 格式的今日日期
   \TeX  \LaTeX  \LaTeXe    用特殊形式显示这些单词
   \~    产生在上的小的波浪号
   $\sim$    产生在中部位置的大的波浪号
   \ldots    省略号
   $\pi$     符号 pi

   可用如下格式产生摄氏度的符号(以 -30 度为例):
   $-30\,^{\circ}\mathrm{C}$
   textcomp 宏包里有另一个度的符号 \textcelsius

   使用欧元符号，先导入 textcomp 宏包
   \usepackage{textcomp}
   然后使用命令
   \texteuro
   来生成欧元符号。但需要系统字体提供欧元符号。

   在 LaTeX 中，用两个 ` 产生左引号，用两个 ' 产生右引号，' 产生单引号。

   -     连字号
   --    短破折号
   ---   长破折号
   

   可在 \documentclass 和 \begin{document} 之间添加如 \author{} 、
   \title{} 之类的格式，然后在  \begin{document} 下添加 \maketitle 即
   可生成 title。

   通常有些单词会出现连字(ligature),在两个字母间插入一个 \mbox{} 可禁
   止连字，这对由两个词够成的单词，这可能必要。如
   Not shelfful but shelf\mbox{}ful
   
   空格前的反斜线符号产生一个不能伸长的空格。
   波浪字符 ~ 也产生一个不能伸长的空格，且禁止断行。
   句号前的命令 \@ 说明这个句号是句子的末尾，即使它紧跟一个大写字母。
** 5、注释
   LaTex 对遇到的每个 % ，将会忽略 % 后的该行内容、换行符及下一行前的
   空白字符。也可用它来断开不能含有空白字符或换行符的较长输入内容。
   当注释过长时，可用 verbatim 宏包提供的 comment 环境，格式为 
   \usepackage{verbatim}
   % 正文
   \begin{comment}
   注释
   \end{comment}
   但以上做法在数学环境等复杂环境中不起作用。
** 6、文档布局
*** 1、基本格式
   \documentclass[options]{class}
   其中，class 指明了所要创建的文档类型，options 可定制文档类的属性，
   不同的选项间用逗号隔开。

*** 2、class 可选的类别
    article    排版科学期刊、演示文档、短报告、程序文档、邀请函等
    proc       一个基于 article 的会议文集类
    minimal    非常小的文档类，只设置了页面尺寸和基本字体，主要用来查
               错
    report     排版多章节长报告、短篇书籍、博士论文……
    book       排版书籍
    slides     排版幻灯片，该文档类使用大号 sans serif 字体，也可选用
               FoilTEX 来得到相同的效果。
*** 3、options 可选的类别
    10pt,11pt,12pt    设置文档中所使用的字体大小，默认是 10pt 
    a4paper,letterpaper,a5papter, b5paper, executivepaper, legalpaper
    定义纸张尺寸，默认是 letterpaper
    flegn 设置行间公式为左对齐，而不是居中对齐。
    leqno 设置行间公式的编号为左对齐，而不是右对齐。
    titlepage, notitlepage 制定是否在文档标题后另起一页。article 文档
                           缺省设置为不开始新页，report 和 book 类则相
			   反。
    onecolumn, twocolumn 制定 LaTex 以单栏或双栏方式排版文档。
    twoside, oneside 指定文档为双面或单面打印格式。article 和 report
                     类为单面，book 类缺省为双面格式。注意该选项只是作
		     用于文档样式，而不会通知打印机以双面格式打印文档。
    landscape 将文档的打印输出布局设置为 landscape 模式。
    openright, openany 决定新的一章是仅在奇数页开始还是在下一页开始。
                       在 article 类中该选项不起作用，因为该类中没有定
		       义“章”(chapter)。report 类默认在下一页开始新
		       一章，而 book 类的新一章总是在奇数页开始。
***
** 7、宏包
   想插入图形、彩色文本或源代码等增强功能到文档中时，需要使用宏包来增
   强它的 LaTex 的功能。调用宏包格式为
   \usepackpage[options]{package}
   /package/ 是宏包名称, /options/ 是用来激活宏包特殊功能的一组关键词。
   随 LaTex 基本发行版一起发布的宏包有：
   doc 排版 LaTex 的说明文当。具体描述见 doc.dtx 及 The LaTex
       Companion
   exscale 提供了按比例伸缩的数学扩展字体。具体描述见 ltexscale.dtx
   fonttenc 指明使用哪种 LaTex 字体编码。具体描述见 ltoutenc.dtx
   ifthen 提供如下形式命令 'if...then do... otherwise do...'，具体描述
          见 ifthen.dtx 及 The LaTex Companion
   latexsym 提供 LaTex 符号字体。具体描述见 latexsym.dtx 及 The LaTex
            Companion 
   makeidx 提供排版索引的命令。具体描述见 The Latex Companion.
   syntonly 编辑文档而不生成 dvi 文件（常用于查错）
   inputenc 指明使用哪种输入编码，如 ASCII, ISO Latin-1 等，具体描述见
            inputenc.dtx
** 8、页面样式
   LaTex 支持三种预定义的页眉/页脚(header/footer)样式，称为页面样式。
   使用如下命令
   \pagestyle{style}
   其中 /style/ 参数确定了使用哪一种页面样式。
   可通过如下命令来改变当前页面的页面样式
   \thispagestyle{style}
   预定义的页面样式有:
   plain 在页脚正中显示页码。这是页面样式的缺省设置。
   headings 在页眉中显示章节名及页码、页脚空白。
   empty 将页眉、页脚都设为空白。
** 9、注音符号(accent) 和特殊字符(special character)
   参见 lshort 中的总结。
** 10、标题、章、节
   对 article 风格的文档，有下列分节命令： 
   \section{...}
   \subsection{...}
   \subsubsection{...}
   \paragraph{...}
   \subparagraph{...}
   其中{}中的都是标题。
   若想把文档分成几个部分且不影响章节编号，可使用
   \part{...}
   使用 report 或 book 类时，可用另一个高层次的分节命令
   \chapter{...}
   因为 article 类的文档不划分为章，故很容易把它作为一章插入书籍中。节
   之间的间隔、序号和标题的字号由 laTeX 自动设置。
   分节的两个命令有些特别：
   1)命令 \part{...} 不影响章的序号
   2)命令 \appendix 不带参量，只把章的序号改用为字母标记。
   LaTeX 在文档编译的最后一个循环中，提取节的标题和页码以生成目录。命
   令
   \tableofcontents
   在其出现的位置插入目录。为了得到正确的目录内容，一个新文档必须编译
   两次，有时还要编译三次。
   若想以带星的形式出现分节，则在命令后加 * 来实现，如把
   \section{Help} 改为 \section*{Help} 。它们生成的节标题既不出现于目
   录，也不带序号。（我试了试，有些问题，不能显示 *）
   目录出现的标题，一般与输入的文本完全一致。有时这不可能，因为标题太
   长排不进目录。这种情况下，目录的条目可由实际标题前的可选参量确定。
   如
   \chapter[Title for the table of contents]{A long and especially
   boring title, shown in the text}
   
   整篇文档的标题由命令
   \maketitle
   产生。标题的内容必须在调用 \maketitle 前，由命令
   \title{...}    \author{...}    \date{...}
   定义。在命令 \author{...} 的参量中，可输入几个用 \and 命令分开的名
   字。
   LaTeXe 引进了其他三个命令用于 book 风格的文档：
   \frontmatter 应接着命令 \begin{document} 使用。它把页码更换为罗马数
                字，且章节不计数。当使用带星的分节命令(如
		\chapter*{Preface}) 时，这些章节不会出现在目录里。
   \mainmatter 应出现在书的第一章前面。它启动阿拉伯数字的页码计数器，
               并对页码重新计数。
   \appendix 标志书中附录材料的开始，该命令后的各章序号改用字母标记。
   \backmatter 应插入与书中最后一部分内容的前面，如参考文献和索引。在
               标准文档类型中，它对页面没效果。
** 11、交叉引用
** 12、注脚
   命令
   \footnote{footnote text} 
   把注脚内容排印于当前页的页脚位置。注脚命令总是置于其指向的单词或句
   子的后面。注脚是一个句子或句子的一部分，故应用逗号或句号结尾。
** 13、强调
   \underline{text}    在 text 下加下划线
   \emph{text}    对其中的 text 其强调作用，字体与前后不同
   \textit{text}    text 都是斜体
   \textsf{text}    text 都是 sans-serif 字体
   \texttt{text}    text 是用一种特殊字体表示
** 14、环境
   为排版专用文本，LaTeX 定义了不同格式的环境：
   \begin{environment} text \end{environment}
   其中 envirionment 是环境名称，只要保持调用顺序，环境可嵌套。
*** 1、itemize、enumerate、description
    itemize 环境用于简单的列表，enumerate 环境用于带序号的列表，
    description 环境用于带描述的列表。
    例如
    \begin{enumerate}
    \item 文本
    \item 文本
    \end{enumerate}
    或
    \begin{itemize}
    \item 文本      % 默认在文本前添加居中的黑点
    \item[-] 文本   % 在文本前用 - 代替 居中的黑点
    \end{itemize}
    或
    \begin{description}
    \item[名称] 文本
    \item[名称] 文本
    \end{description}
    这些都可嵌套使用。
*** 2、左对齐、右对齐、居中
    flushleft 和 flushright 环境分别产生左对齐和右对齐的段落。center
    环境产生居中的文本。若不输入命令 \\ 指定断行点，LaTeX 将自行决定。
*** 3、引用、语录和韵文
    quote 环境可用于引文、语录和例子。
    有两个类似的环境：quotation 和 verse 环境。quotation 环境用于超过
    几段的较长引用，因为它对段落进行缩进。verse 环境用于诗歌。
*** 4、摘要
    科学出版物惯常以摘要开始，来给读者一个综述或预期。LaTeX 为此提供了
    abstract 环境。一般 abstract 用于 article 类文档。
*** 5、原文打印
    位于 \begin{verbatim} 和 \end{verbatim} 之间的文本将直接打印，包括
    所有的断行和空白，就像在打字机上键入一样，不执行任何 LaTeX 命令。
*** 6、表格
    
** 15、表格
   tabular 环境能用来排版带有水平和垂直表线的漂亮表格。 LaTeX 自动确定
   每一列的宽度。
   命令
   \begin{tabular}[pos]{table spec}
   的参量 table spec 定义了表格的格式。用 l 产生左对齐的列，用 r 产生
   右对齐的列，用 c 产生居中的列;用 p{width} 产生相应宽度、包含自动断
   行文本的列（用在 {table spec} 中,如 \begin{tabular}{|p{4.7cm}|}）; | 产生垂直表线。
   若一列里的文本太宽，LaTeX 不会自动折行显示。使用 p{width} 可以定义
   如一般段落里折行效果的列。
   参量 pos 设定相对于环绕文本基线的表格垂直位置。使用字母 t、b、c 来
   设定表格靠上、靠下或居中的位置。
   在 tabular 环境中，用 & 跳入下一列，用 \\ 开始新的一行，用 \hline
   插入水平表线。用 \cline{j-i} 可添加部分表线，其中 j 和 i 分别表示表
   线的起始列和终止列的序号。
   在 {table spec} 中要指明列数，如
   \begin{tabular}{|r|l|c|} 
   表明生成三列，第一列右对齐，第二列左对齐，第三列居中对齐。所做的表
   格的列数一定要在此表示出来，且必须要指明对齐方式。
   使用 \cline{j-i} 时，一般是在所在行的 \\ 后使用，要注意，若要在所在
   行的第一列下添加表格线，用 \cline{1-1}，若要在第二列下添加表格线，
   用 \cline{2-2}，以此类推。
   表格的列分隔符可由 @{} 构造，这个命令去掉表列之间的间隔，代之为两个
   花括号间的内容。如
   \begin{tabular}{@{} l @{}}
   \hline
   no leading space \\
   \hline
   \end{tabular}
   或
   \begin{tabular}{l}
   \hline
   leading space left and right \\
   \hline
   \end{tabular}
   有个小技巧，在紧接上面的第一个例子中，可在 @{} 的花括号内添加自己想
   要的符号，把 @{} 放在表格的首尾，则每行都会在首尾产生相应的符号。
   在 \begin{tabluar}{} 第二个花括号中若用 @{} 作列分隔符，用法同 | 的
   一样，我想 @{} @{} 的效果同 || 类似，但 || 之间必须指明对齐方式，而
   前者可不指定。
   有个命令是 
   \multicolumn{num}{form}{name}
   其中 num 指列数， form 指对齐方式，name 是列名，一般在第一列后使用
   这个命令，如
   \begin{tabular}{c r @{.} l}
   Pi expression &
   \multicolumn{2}{c}{Value} \\
   \hline
   $\pi$ & 3&1416 \\
   $\pi^{\pi}$ & 36&46 \\
   $(\pi^{\pi})^{\pi}$ & 80662&7 \\
   \end{tabular}
   或
   \begin{tabular}{|c|c|}
   \hline
   \multicolumn{2}{|c|}{Ene} \\
   \hline
   Mene & Muh! \\
   \hline
   \end{tabular}
   用表格环境排印的材料总是应放在同一页，若要排印一个长表格，可看下
   supertabular 和 longtabular 环境。
** 16、
** etc
   1) LaTex 不同于其它排版系统之处在于，你必须告诉它文本的逻辑和语义结
      构，然后它根据类文件和各种样式文件中给定的“规则”生成相应格式的
      文本。
   2）段落(paragraph)是连续思想或观点在排版上的反映。
   3）为使输出的右边界对齐，LaTeX 在单词间插入不等的间隔。在句子的末尾
      插入的空间稍多一些，因为这使得文本更具有可读性。LaTeX 假定句子以
      句号、问号或惊叹号结尾。若句号紧跟一个大写字母，它就不视为句子的
      结尾，因为一半在有缩写的地方，才出现句号紧跟大写字母的情况。
   4）可利用 \\ 或 \newline 来换行，若不同的行之间有空行，则表示新生成
      一段，每段的第一行都会缩进，否则只产生新行，则不会进行缩进。
* 多核编程
* GPU 编程
* 讨论
** 1、挂载 U 盘
   挂载 U 盘时，使用 
   # cat /proc/partitions
   时多出了两个设备，为
   
   major minor #blocks  name
   8     16    3913728  sdb
   8     17    3913696  sdb1
   
   使用 
   # fdisk -l
   时会给出详细些的信息
   
   Disk /dev/sdb: 4007 MB, 4007657472 bytes
   255 heads, 63 sectors/track, 487 cylinders, total 7827456 sectors
   Units = sectors of 1 * 512 = 512 bytes
   Sector size (logical/physical): 512 bytes / 512 bytes
   I/O size (minimum/optimal): 512 bytes / 512 bytes
   Disk identifier: 0xccd4ebea

   Device Boot      Start         End      Blocks   Id  System
   /dev/sdb1   *          63     7827455     3913696+   b  W95 FAT32

   挂载 sdb 时提示
   mount: /dev/sdb: can't read superblock

   综合这三方面的信息，我觉得挂载 U 盘时会挂载两个分区的原因是，一个是
   U 盘的控制逻辑，另一个是可存储信息的物理磁盘。
   但有个疑惑是，挂载 MP4 时却只显示 sdb ，这很奇怪。

   插上 U 盘后，用
   # fdisk -l
   可发现，硬盘的信息显示格式与 U 盘的相同，它们的 heads 和
   sectors/track 数目项目，柱面数不同，这个不理解
* Wiki
  访问地址是：
  http://ip/wiki 
* MySQL 相关
** 修改 MySQL root 密码
   若原密码为空，则用
   # mysqladmin -u root password "newpass"
   来设置，若有密码，则用
   # mysqladmin -u root password  oldpass "newpass"
** 无法启动
   检查下 /var/lib/mysql/ 中文件的 owner 和 group,都改为 mysql.修改方法为:
   # chown -R mysql.mysql /var/lib/mysql
   然后再启动 mysqld_safe ，若依旧不行，则再在 /etc/rc.d/ 中启动 rc.mysqld,方法
   是
   # rc.mysqld start
   这个其实可以看下 /etc/rc.d/rc.mysqld 脚本，其中有提示。
** 出现 ERROR 1045(28000)
   解决方法:
   # pkill mysql
   # mysqld_safe --user=mysql --skip-grant-tables --skip-networking &
   # mysql -u root mysql
   mysql> UPDATE user SET Password=PASSWORD('newpassword') WHERE USER='root' and
   host='root' or host='localhost';
   mysql> FLUSH PRIVILEGES;
   mysql>quit
   # mysqld_safe &
   # mysql -uroot -p
** PHP 与 MySQL 连接
   不管是在 Windows 下还是 Linux 下，只有 MySQl 安装时配置好，在安装成功后就不用
   再配置 MySQL 即可通过 PHP 访问 MySQL。Windows 下的 MySQL 要完全安装，Linux 下
   的 MySQL 默认编译安装就行。
** 我的 mysql root 密码
   zyf103
** ERROR 2002 (HY000)
   先检查 /var/run/mysql/mysql.sock 文件是否存在，若不存在，建立一个。然后关闭
   mysql,再重启 mysql.
** 查看 MySQL 端口号
   进入 MySQL 后，可用 
   show variables like "port";
   来查看。
   默认的是 3306.
* Apache 相关
** 支持 PHP
   修改 /etc/httpd/httpd.conf 文件，改为:
   DirectoryIndex index.html index.shtml index.cgi index.php index.phtml
   index.php3
   ServerName www.example.com:80 (不同的机器上 ServerName 可能不相同)
   把如下部分添加到文件末尾:
   AddType application/x-httpd-php .php .php3 .phtml .inc
   AddType application/x-httpd-php-source .phps
   把一部分修改为:
   <Directory />
    Options FollowSymLinks
    AllowOverride None
    Order deny,allow
    Deny from all
    </Directory>
** 常见问题
   可能会出现
   httpd: Could not reliably determine the server's fully qualified domain
   name, using 127.0.0.1
   修改 httpd.conf 文件，找到#ServerName www.example.com:80   把#去掉，再重启
   apache即可没事了。
   有时还可能出现一直无法启动 httpd, 那么就设置 httpd 为随机启动的守护进程，然后
   重启计算机。
** 无权限访问
   设置好后，在浏览器输入 127.0.0.1 后显示
   You don't have permission to access / on this server.
   解决方法是修改 httpd.conf 文件，把
   <Directory />
    Options FollowSymLinks
    AllowOverride None
    Order deny,allow
    Deny from all 
    </Directory>
    改为:
    <Directory />
    Options Indexes FollowSymLinks
    AllowOverride None
    </Directory>
* Slackware 启动过程
  The first program to run under Slackware besides the Linux kernel is *init(8)*
  . This program reads the */etc/inittab(5)* file to see hwo to run the
  system. It runs the */etc/rc.d/rc.S* script to prepare the system before goin
  into your desired runlevel. The *rc.S* file enables your virtual memory,
  mounts your filesystems, cleans up certain log directories, initializes Plug
  and Play devices, loads kernel modules, configures PCMCIA devices, sets up
  serial ports, and runs System V init scripts (if found). 
  After system initalization is complete, *init* moves on to runlevel
  initialization. A runlevel describes the state that your machine will be
  running in. The runlevel tells *init* if you will be accepting multiuser
  logins or just a single user, whether or not you want networ services, and if
  you will be using the X Window System or *agetty(8)* to handle logins. 
* X
  X is responsible for providing a graphical user interface. It is independent
  from the OS.
  The X Window System is implemented through many programs that run in
  user-land. The two main components are *the server* and *the window
  manager*. The server provides the lowlevel functions for interacting with your
  video hardware, thus it is system specific. The window manager sits on top of
  the server and provides the user interface. The advantage to this is you can
  have many different graphical interfaces by simply changing the window manager
  you use.
  Configuring X can be a complex task. The reason for this is the vast numbers of
  video cards available for the PC architecture, most of which use different
  programming interfaces. Luckily, most cards today support basic video standards
  known as VESA, and if your card is among them you'll be able to start X using
  the *startx* command right out of the box.
  If this doesn't work with your card, or if you'd like to take advantage of the
  hight-performance features of your video card, then you'll need to reconfigure
  X.
  To configure X, you'll need to make an */etc/X11/xorg.conf* file. 
* 链接
  *Hard links* are names for a particular file. They can only exist within a
  single filesystem and are only removed when the real name is removed from the
  system. 
  *Soft link*, also called a symbolic link, can point to a file outside of its
  filesystem. It is actually a small file containing the information it needs. You
  can add and remove soft links without affecting the actual file. And since a
  symbolic link is actually a small file containing its own information, they can
  even point at a directory. 
  Links do not have their own set of permissions or ownerships, but reflect thost
  of the file they point to.
  hard links 相当于对同一个 inode 又起了一个名字,会把节点的链结数增加,只要节点的链
  结数不为 0,文件就一直存在.当修改任何一个文件时,所有指向这个节点的文件都会同步修
  改. soft links 对源文件没有影响,删除源文件后,链结就找不到指定的文件,每个 soft
  links 都有自己的 inode,并在磁盘上有小空间存放路径名. soft links 可对一个不存在的
  文件名进行链结,也可对目录进行链结. 
* 安全
  Security is a process, not a state.
** Disabling services
   Services are started from two main places -- *inetd* and init scripts.
*** Services started from /inetd/
    A lot of the daemons that come with Slackware are run from
    *inetd(8)*. *inetd* is a daemon that listens on all of the ports used by
    services configured to be started by it and spawns an instance of the
    relevant daemon when a connection attempt is made. Daemons started from
    *inetd* can be disabled by commenting out the relevant lines in
    */etc/inetd.conf*.
    After *inetd* has been restarted, this service will be disabled. You can
    restart *inetd* with the command:
    # kill -HUP $(cat /var/run/inetd.pid)
*** Services started from init scripts
    The rest of the Services started when the machine starts are started from the
    init scripts in */etc.rc.d/*. These can be disabled to remove the execute
    permissions on the relevant init script or to comment out the relevant lines
    in the init scripts.
    For services that don't have their own init script, you will need to comment
    out the relevant lines in the init scripts to disable them.
    These changes will only take effect after either a reboot or changing from
    adn back to runlevel 3 or 4. You can do this by typing the following on the
    console (you will need to log in again after changing to runlevel 1):
    # telinit 1
    # telinit 3

** Host Access Control
*** iptables
*** tcpwrappers
    *tcpwrappers* Controls Access to daemons at the application level, rather
    than at the IP level. This can provide an extra layer of Security at times
    when IP-level Access Controls (e.g. Netfilter) are not functioning
    correctly. For example, if you recompile the kernel but forget to include
    iptables support, your IP level protection will fail but tcpwrappers will
    still help protect your system.
    Access to services protected by tcpwrappers can be Controlled using
    */etc/hosts.allow* and */etc/hosts.deny*.
    普遍做法是在 /etc/hosts.deny 中添加:
    ALL : ALL
    这样就禁止了所有的服务,然后在 /etc/hosts.allow 中添加允许提供的服务程序,如接
    受所有来自 *localhost* 的连接,可用:
    ALL : 127.0.0.1
    接受来自 192.168.0.0/24 的连接 ssh, 启动 sshd 后台程序,可用:
    sshd : 192.168.0.0/24
    或
    sshd: 192.168.0.
* 计算机基本概念
  资源交换
  资源共享
  资源存储
  通信
* wordpress
** 本地用户名
   admin
** 安装主题
   把下载的主题解压后放在 wp-content/themes 目录下即可。
** 安装主题
   把下载下来的插件解压后放在 wp-content/plugins 目录下即可。
* dokuwiki
** 用户名
   super user: admin
   user: flyer
* Google 和 OpenDNS 
  IPv4:
  8.8.8.8
  8.8.4.4
  208.67.222.222
  208.67.220.220
  IPv6:
  2001:4860:4860::8888
  2001:4860:4860::8844
  2620:0:ccc::2
  2620:0:ccd::2
* 在线 web 代理
  在线Web代理原理： Web Proxy，顾名思义，就是用Web服务器当作代理服务器（Proxy），
  通过在Web服务器上运行PHP或CGI脚本来使服务器拥有代理服务器的功能。在线Web代理都
  是全匿名（high anonymity）类型的。 
  HTTP代理和在线Web代理的区别： 在 线Web代理使用起来比HTTP代理要简便得多，HTTP代
  理在使用前要对浏览器进行设定才可以使用.
* HTTP 代理
** HTTP代理的匿名性 
   HTTP代理匿名性是指不通过非常技术手段，直接使用时代理的匿名安全性。（说明：这
   里的匿名与其它如FTP服务器的匿名意义是不一样的，不论匿名与否，代理服务器均能起
   到“代理”的作用。只是匿名代理可以确保被访问方不能追溯到源IP，在一定程度上更
   加安全而已。这并不是一个重要的指标，是否必要则 仁者见仁、智者见智。）
** HTTP CONNECT代理 
   对于HTTP代理，不少人有认识上的误区，有必要说明一下，不是所有的HTTP代理都只能
   代理HTTP的。HTTP CONNECT代理服务器是一种能够允许用户建立TCP连接到任何端口的代
   理服务器，这意味着这种代理不仅可用于HTTP，还包括FTP、IRC、RM流 服务等，甚至扫
   描、攻击。 
** 三种代理的区别
*** 全匿名代理（high anonymity)
    不改变你的request fields，使服务器端看来就像有个真正的客户浏览器在访问它。当
    然，你的真实IP是隐藏起来的。服务器的网管不会认为你使用了代理。
*** 普通匿名代理（anonymous)
    能隐藏你的真实IP，但会更改你的request fields，有可能会被认为使用了代理，但仅
    仅是可能，一般说来是没问题的。不过不要受它的名字的误导，其安全性可能比全匿名
    代理更高，有的代理会剥离 你的部分信息（就好比防火墙的stealth mode），使服务
    器端探测不到你的操作系统版本和浏览器版本。
*** 透明代理（transparent)
    改编你的request fields，并会传送真实IP.

* 代理服务器基础及原理简介
  代理服务器英文全称是Proxy Server，其功能就是代理网络用户去取得网络信息。形象的
  说：它是网络信息的中转站。在一般情况下，我们使用网络浏览器直接去连接其他
  Internet站点取得网络信息时，须送出Request信号来得到回答，然后对方再把信息以bit
  方式传送回来。

  代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接
  到Web服务器去取回网页而是向代理服务器发出请求，Request 信号会先送到代理服务器，
  由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。

  大部分代理服务器都具有缓冲的功能，就好象一个大的Cache，它有很大的存储空间，它
  不断将新取得数据储存到它本机的存储器上，如果浏览器所请求的数据在它本机的存储器
  上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数
  据传送给用户的浏览器，这样就能显著提高浏览速度和效率。更重要的是：Proxy Server
  (代理服务器)是 Internet 链路级网关所提供的一种重要的安全功能，它的工作主要在开
  放系统互联 (OSI) 模型的对话层。主要的功能有：

  1、连接Internet与Intranet 充当firewall（防火墙）：因为所有内部网的用户通过代理
  服务器访问外界时，只映射为一个IP地址，所以外界不能直接访问到内部网；同时可以设
  置IP地址过滤，限制内部网对外部的访问权限；另外，两个没有互联的内部网，也可以通
  过第三方的代理服务器进行互联来交换信息。

  2、节省IP开销：如前面所讲，所有用户对外只占用一个IP，所以不必租用过多的IP地址，
  降低网络的维护成本。这样，局域局内没有与外网相连的众多机器就可以通过内网的一台
  代理服务器连接到外网，大大减少费用。当然也有它不利的一面，如许多网络黑客通过这
  种方法隐藏自己的真实IP地址，而逃过监视。

  3、提高访问速度：本身带宽较小，通过带宽较大的proxy与目标主机连接。而且通常代理
  服务器都设置一个较大的硬盘缓冲区（可能高达几个GB或更大），当有外界的信息通过时，
  同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信
  息，传给用户，从而达到提高访问速度的目的。
* chrome
** 查看缓存
   在地址栏输入:
   chrome://cache
   点击任意个 cache 信息，都能获得完整的服务器应答信息。











** 默认 https 连接
   地址栏输入 chrome://net-internals/
   在 HSTS 的标签栏里 Domain 里填上需要访问的 domain，比如 twitter.com
   然后选中 Include subdomains 点击 Add 按钮即可，可以加多个域.
   这样所有访问这个域名（包括子域名）都自动转到 https 了.
* Nginx
** 编译安装的默认路径
   /usr/local/nginx/
** 检查默认位置配置文件是否正确
   # nginx -t

** nginx.conf
   主要包括三部分:全局配置、I/O 事件配置和 HTTP 配置。
** nginx: [emerg] unknown directive "stub_status"
   在编译时添加了 --with-help_stub_status_module 并在 nginx.conf 中添加了相应的
   配置，如，
   
   location ~ /status {
       stub_status on;
	   access_log off;
   }
   
   时，通过 $PATH 路径中的 nginx 检查配置文件时可能会出现这个问题。
   一个解决方法是通过安装时的 nginx 目录来启动 nginx。

** 查看网站被访问的相关信息
   在配置好 stub_status 后，在浏览器中输入:

   域名/status

   来查看。
* PHP
** pear 安装 syck-beta 时错误
   可先去 http://rubyforge.org/frs 下载 syck 来安装，然后再通过 pear 安装
   syck-beta.
* GUI 编程
** Brief
   如果想要在 panel 上编程显示程序图标的功能，首先要明白 *系统托盘(system
   panel)* 的概念，它是用来显示正在运行的程序的图标。如果想要实现桌面提醒功能，
   要明白 *通知提醒* 的概念。
   明白这两个概念后，不懂的地方就可以很快 google 到。
** python 下系统托盘图标显示和通知提供的类
   分别是 appindicator 和 pynofiy
** GTK 下系统托盘图标显示和通知提供的库
   libegg
