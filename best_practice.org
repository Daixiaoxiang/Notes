* 系统资源
  写代码前，先通过:
  $ ulimit -a
  查看下系统的资源限制.
* 程序对资源的使用
  不能无限制使用资源，必须对使用的资源进行控制，可通过 ulimit 查看需要控制的资源. 
* pid 资源
  运行的程序最好把自己的 pid 写入到一个固定的文件中，便于一些监控工具对该程序进
  行监控.
* 日志
** 总的原则
   做大多数的操作一定要有日志的输出，便于对程序的运行进行查询.
   一般需要提供两种类型的日志服务，一种是在屏幕打印，一种是写入到文件中.
** 日志记录的内容
   可把代码看成 'Input-->Handle-->Output' 的模型，一般需要记录:
   + 输入的数据
   + 处理的数据
   + 输出的数据
* 函数
** 参数
   函数的参数是函数内部所有需要的外部数据，不要在函数内部依赖全局变量.
** 副作用
   函数尽量不要有副作用，同样的输入要有同样的结果。
* 问题分析
  一般可按照如下的基本进行:
  + 现状 (what)
  + 问题 (why)
  + 目标 (goal)
  + 解决方案 (how)
* 计数器
  想清楚一个项目关注哪些指标，计数器宁可多也不要少.
  不要考虑通过分析 log 来计数.
* 使用数据库或其他外部服务
  有几个总结:
  + 一定要加异常处理
  + 最好是有一个公用模块处理与外部服务相关的操作，而不要在不同的模块中都实现一个
    与外部服务交互的方法
* 对数据库连接建立成功与否的判断
  不同语言使用不同的 client 连接数据库后，对该连接是否成功的判断机制可能不一样.
  在使用数据库的 client 时，需要确认连接机制是什么，合理判断是否需要在建立连接后
  执行 ping() 操作.

  以 python 中的 pymysql、redis-py、pymongo 为例:
  + pymysql 会在建立连接时就判断连接是否建立成功，故不需要在连接后再通过 ping()
    来判断连接是否可用
  + redis-py 不会在建立连接时就判断连接是否建立成功，需要在连接建立后通过一些命令，
    如 ping()，来判断连接是否可用
  + pymongo 会在连接时就判断连接是否建立成功，故不需要在连接后再通过 alive() 来
    判断连接是否可用 
* 对数据库的连接数
  由于数据库的连接数有限制且与 OS 所能提供的 socket 数有关，故设计对数据库的使用
  时，需要考虑数据库连接数的限制，可能需要考虑通过 connection pool 来控制。但用
  到 connection pool 时，需要考虑到多线程的情景，需要确保 connection pool 是线程
  安全的.
* python 中 json.dumps() utf-8 数据
  必须显式指定参数 'ensure_ascii=False'，否则可能不会与 redis-py 这样的客户端正
  确交互.
