* enum
  enum 提供了创建符号常量的方式，可替代 const。
  在默认情况下，将整数值赋给枚举量，第一个枚举量的值是 0, 第二个枚举量的值是 1,
  依次类推。可通过显式地指定整数值来覆盖默认值。
  在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量。

  对于枚举，只定义了赋值操作符。
 
  枚举量是整型，可被提升为 int 类型，但 int 类型不能自动转换为枚举类型。

  枚举更常被用来定义相关的符号常量，而不是新类型。若只使用常量，而不创建枚举类型
  的变量，则可省略枚举类型的名称。

  可创建多个值相同的枚举量，如
  enum {zero, null=0, one, numero_uno = 1};

  枚举的取值范围:
  要找出上限，需要知道枚举量的最大值。找到大于这个最大值的、最小的 2 的幂，将它
  减去 1,得到的便是取值范围的上限。
  要计算下限，需要知道枚举量的最小值。若它不小于 0,则取值范围的下限是 0；否则，
  采用与寻找上限方式相同的方式(用绝对值)，但加上负号。

  选择多少空间来存储枚举由编译器决定。
* 计算机程序在存储数据时必须跟踪的 3 种基本属性
  1)信息存储在何处        (地址)
  2)存储的值为多少        (值)
  3)存储的信息是什么类型   (类型)
* 面向对象与面向过程在决策方面的区别
  OOP 与面向过程编程的区别在于，OOP 强调的是在 *运行阶段* (而不是 *编译阶段*) 进
  行决策。运行阶段决策就好比度假时，选择参观哪些景点取决于天气和当时的心情;而编
  译阶段决策更像不管在什么条件下，都坚持预先设定的日程安排。
  运行阶段决策提供了灵活性，可根据当时的情况进行调整。
* 内存泄漏 (memory leak)
  即已分配的内存无法再被使用。

* new/delete
** 使用原则
   1)不要使用 delete 来释放不是 new 分配的内存。
   2)不要使用 delete 释放同一个内存块两次。
   3)若使用 new [] 为数组分配内存，则应使用 delete [] 来释放。
   4)若使用 new [] 为一个实体分配内存，则应使用 delete (没有方括号) 来释放。
   5)对空指针应用 delete 是安全的。
** new
   使用 new 时，是在堆区分配了块内存，除非使用 delete 来释放这块区域，否则它一直
   存在，即使是在函数中使用 new 分配内存。
* 指针和数组基本等价的原因
  1) 指针算术和 C++ 内部处理数组的方式相同。如将整数变量加 1 后，其值将增加 1，
     但将指针变量加 1 后，增加的量等于它指向的类型的字节数。
* sizeof() 作用
** 作用在数组名时
   得到的是数组的总的字节数，而不是指针的字节数。
   若想获得数组名(是数组的头指针)的字节数，可用 (int *) arr_name 的形式，把数组
   名强制解释为指针。注意强制转换的类型为 int *，而不是其它的类型。
* 解除指针引用的方法
  法一: 使用 *p.
  法二: 若指针 p 是指向数组的指针，可把它当作数组名来用，如 p[1].
* 指针相减
  仅当两个指针指向同一个数组(也可指向超出结尾的一个位置)时，这种运算才有意义，将
  得到两个数组元素的位置间隔。
* 给 cout 提供一个字符的地址
  它将从该字符开始打印，直到遇到空字符为止。
  在 cout 和多数 C++ 表达式中，char 数组名、指向 char 的指针及用引号括起的字符串
  常量都被解释为字符串第一个字符的地址。

* 存储方式
** 自动存储
   局部变量。
** 静态存储
   包括全局变量和使用 static 修饰的变量.
** 动态存储
   即用 new 分配内存的变量，要配合 delete 来使用。

* 字符串
** Brief
   _字符串是以空字符为结尾的一系列字符_.
   字符串可用引号括起的字符串常量表示，其中隐式包含了结尾的空字符。
   可将字符串存储在 char 数组中，可用被初始化为指向字符串的 char 指针表示字符串。
   函数 strlen() 返回字符串的长度，其中不包括空字符。

   字符串字面值是常量，声明时一般对它的变量加上 const 修饰符。C++ 不能保证字符串
   字面值被唯一地存储，即，若在程序中多次使用了字符串字面值，则编译器可能存储该字
   符串的多个副本，也可能只存储一个副本。
** 字符串比较
   对于 C 风格字符串,用 <cstring> 头文件中的 strcmp() 函数来比较.对于 string 类
   型的字符串,则可直接通过 ==,>,< 等符号来比较,还可把 string 类型的字符串当作一
   般的字符数组来用,如
   string test = "flyer";
   cout test[3];
* cin 模拟 EOF
  若编程环境能够检测到 EOF,则在用户通过键盘模拟文件结尾 EOF 时,cin 将两位
  (eofbit 和 failbit) 都设置为 1.
  若检测到 EOF,则 cin.eof() 将返回 true,否则返回 false.
  若 eofbit 或 failbit 被置为 1,则 cin.fail() 成员函数返回 true,否则返回 false.
  更多的是应用 cin.fail() 来检测.
  在模拟 EOF 检测到结束后, cin 将不再起作用,若要继续输入,可通过 cin.clear() 来清
  除 EOF 标记,可使输入继续.
  
  在 Linux 下,用户按下 C-d 模拟 EOF;
  在 Windows 下,用户按下 C-z 模拟 EOF. 
* 函数
** 函数返回值
   C++ 函数的返回值不能是数组，但可以是其它任何类型——整数、浮点数、指针，甚至是结
   构和对象。虽然 C++ 函数不能直接返回数组，但可将数组作为结构或对象组成部分来返
   回。
   通常，函数通过将返回值复制到指定的 CPU 寄存器或内存单元中来将其返回。随后，调
   用程序将查看该内存单元。返回函数和调用函数必须就该内存单元中存储的数据的类型达
   成一致。函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类
   型的数据。
** 为什么需要函数原型
   原型描述了函数编译器的接口，即，它将函数返回值的类型(若存在的话)及参数的类型
   和数量告诉编译器。以下为例:
   double cube(double x);
   首先，原型告诉编译器，cube() 有一个 double 参数。若程序没有提供这样的参数，原
   型将让编译器能够捕获这种错误。其次，cube() 函数完成计算后，将把返回值放置在指
   定的位置——可能是 CPU 寄存器，也可能是内存中。然后调用函数(很多情况下是
   main())将从这个位置取得返回值。由于原型指出了 cube() 的类型为 double,因此编译
   器知道应检索多少个字节及如何解释它们。

   函数原型不要求提供变量名，有类型列表就足够了。原型中的变量名相当于占位符，故
   不必与函数定义中的变量名相同。

** 函数参数是数组
   若函数参数是数组，一般都需要知道数组的长度，可在函数的参数列表中加入数组长度
   的参数。
* struct
** 函数
   C++ 中的 struct 和 class 很像，可以继承类，也可以定义函数。区别在于，struct
   中的变量或函数默认都是 public.
* FAQ
** '\n' 与 std::endl 的区别
   二者的作用都是换行，但 std::endl 会在换行时把数据进行 flush，而 '\n' 不会。

   Ref:
   + [[http://stackoverflow.com/questions/213907/c-stdendl-vs-n][stackoverflow]]
   + [[http://cppkid.wordpress.com/2008/08/27/why-i-prefer-n-to-stdendl/][一篇博客]]

   Note:
   + Anything to be output is first queued into an output buffer and written to
     the device (hard disk, monitor, etc.)  when the queue is full.
	 This is to ensure speed of execution as the access to the external device
     is less frequent.
   + If you are in a situaton where you have to avoid buffering, you can use
     std::endl instead of '\n'. An example of the above situation is when you
     are using old style debugging using multiple count statements between code
     lines to see exactly a crash occurs.
