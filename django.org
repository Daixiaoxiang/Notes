* 说明
  该文档针对 django1.5
* 创建相关
  创建一个项目
  $ django-admin.py startproject 项目名

  在一个项目中创建一个 app
  $ python manage.py startapp 应用名
* 修改 ip:port
  $ python manage.py runserver [ip:port]
  $ python manage.py runserver [port]
* 数据库相关
  更新数据库
  $ python manage.py syncdb
  The *syncdb* command runs the SQL from *sqlall* on your database for all apps
  in *INSTALLED_APPS* that don't already exist in your database. *syncdb* can be
  called as often as you like, and it will only ever create the tables that
  don't exist.

  检验 model 构造中是否有错
  $ python manage.py validate

  检查某个 app 的索引信息
  $ python manage.py sqlindexes app名

  查看某个 app 数据库所有相关的
  $ python manage.py sqlall app
* Model
** sync 数据库后又修改了 model
   此时需要先删除修改的表，然后再 manage.py sync.
** 设置 primary key
   可在 model 的 field 中加参数 "primary_key=True".
* View
** 功能.
   A view is a callable which takes a request and returns a response.
** function-based views
** class-based views
*** 概述
	Allow you to structure your views and reuse code by harnessing inheritance
	and mixins.

	All views inherit from the *View* class, which handles 
	  + linking the view in the URLs
      + HTTP method dispatching
      + other simple features.

	重要的 method:
	+ class.as_view(*initkwargs*)
	  Returns a callable view that takes a request and returns a response.

	  Any arguments passed to *as_view* will override attributes set on the
      class.

	  It servers as the callable entry point to your class. The *as_view()*
      entry point creates an instance of your class and calls its *dispatch()*
      method. *dispatch()* looks at the request to determine whether it is a
      GET, POST, etc, and relays the request to a matching method if one is
      defined, or raises *HttpResponseNotAllowed* if not.

	  返回的是 HttpResponse object.
*** 与 function-based views 对比优势
	Class-based views do not replace function-based views, but have advantages:
	+ Organization of code related to specific HTTP methods (GET, POST, etc.)
      can be addressed by separate methods instead of conditional branching.
	+ Object oriented techniques such as mixins (multiple inheritance) can be
      used to factor code into reusable components.
*** 两种使用方法
	+ simple usage in your URLconf
	  直接在 url 配置文件中使用三个基本的 view class.
	+ subclassing generic views
	  在 view 文件中写个继承自 view class 的 class，然后在 url 配置中使用该
      class.
*** 三个基础 View Class
	+ *View*
	  class django.views.generic.base.View
	  
	  The master class-based base view. All other class-based views inherit
      from this base class.
	+ *TemplateView*
	  class django.views.generic.base.TemplateView
	  
	  Renders a given template, with the context containing parameters captured
      in the URL.
    + *RedirectView*
	  class django.views.generic.base.RedirectView
	  
	  Redirects to a given URL.
*** Note
	+ You can only inherit from one generic view -- that is, only on parent
      clss may inherit from *View* and the rest (if any) should be
      mixins. Trying to inherit from more than one class that inherits
      from *View* won't work as expected.
** generic views
*** 概述
	本质上也是 class-based views，只是把 web 开发过程中使用 class-based views 时
	的一些共性抽象出来，形成可以完成一类任务的 class-based views.

	如果使用 generic views 过程中发现逻辑上处理越来越困难，可重新选择
	function-based views 或 class-based views.
*** class attributes
	+ model
	  指示使用的 model
	+ context_object_name
	  定义模板中使用的与 model 数据相关的名称，修改 generic views 默认的名称，使
      可读性更强
* Form
** 包含 4 种概念
   + Widget
	 A class that corresponds to an HTML form widget, e.g. <input type='text'>
     or <textarea>. This handles rendering of the widgets as HTML.
   + Field
	 A class that is responsible for doing validation, e.g. an 'EmailField'
     that makes sure its data is a valid email address.
   + Form
	 A collection of fields that knowns how to validate itself and display
     itself as HTML.
   + Form Media
	 The CSS and JavaScript resources that are required to render a form.
* 测试
** TDD (Test Driven Development)
   先写测试后写代码，思维过程是 "描述问题-->解决问题".
** 执行
   在 app 的根目录下写完 tests.py 后，在项目的根目录下执行:
   $ python manage.py test app名
** best practice
   + a separate *TestCase* for each model or view
   + a separate test method for each set of conditions you want to test
   + test method names that describe their function
* 部署
** nginx+uwsgi
*** 安装 uwsgi
	$ sudo pip install uwsgi
	
	Note:
	+ 通过 pip 安装，最好不要直接通过系统的包管理器安装，可能会有问题.
*** 测试 uwsgi
	编写 test.py
	
	# test.py
	def application(env, start_response):
	    start_response('200 OK', [('Content-Type', 'text/html')])
		return 'Hello World'

	执行:
	$ uwsgi --http :8001 --wsgi-file test.py
	通过 http://127.0.0.1:8001 访问网页是否有 'Hello World'
*** 仅通过 uwsgi 部署 django
	$ django_admin.py startproject 项目名

	在该项目根目录下添加 django_wsgi.py 文件，

	# django_wsgi.py
	#!/usr/bin/python2.7
	# coding:utf-8

	import os
	import sys
	
	os.environ.setdefault("DJANGO_SETTINGS_MODULE", "项目名.settings")
	
	from django.core.handlers.wsgi import WSGIHandler
	
	application = WSGIHandler()

	部署项目:
	$ uwsgi --http :8000 --chdir /PATH/TO/项目 --module django_wsgi
	把 '/PATH/TO/项目' 改为项目地址，如 '/home/flyer/Practice/项目名'
	通过 http://127.0.0.1:8000 访问项目.
*** 通过 nginx+uwsgi 部署 django
	nginx 处理静态文件，动态文件由 nginx 交给 uwsgi 处理，二者通过 socket 通信.
	假设项目地址 '/home/flyer/Practice/项目名'，nginx 通过 8077 端口与 uwsgi 通信,
	在 '/home/flyer/Practice/项目名/' 根目录下创建 django_wsgi.py(内容同上) 和
	django_socket.xml 文件:

	# django_socket.xml
	<uwsgi>
	    <socket>:8077</socket>
		<chdir>/home/flyer/Practice/项目名/</chdir>
		<module>django_wsgi</module>
		<processes>django_wsgi</processes>
		<daemonize>uwsgi.log</daemonize>
	</uwsgi>

	假设 access.log 和 error.log 放在 '/home/flyer/logs/nginx/' 中，项目中的静态
	文件在 '/home/flyer/Practice/项目/static/' 和 
	'/home/flyer/Practice/项目名/media/' 中，域名端口是 8060.
	修改 nginx.conf (不同的系统该文件地址不一样，搜一下):

	server {
	    listen 8060;
		server_name 域名(本机上可设置为 localhost);

		access_log /home/flyer/logs/nginx/access.log;
		error_log /home/flyer/logs/nginx/error.log;

		location / {
		    include uwsgi_params;
			uwsgi_pass 127.0.0.1:8077;
		}

		error_page 500 502 503 504 /50x.html;
		location = /50x.html {
		    root html;
		}

		location /static/ {
		    alias /home/flyer/Practice/项目/static/;
			index index.html index.htm;
		}

		location /media/ {
		    alias /home/flyer/Practice/项目/media/;
		}
	}

	先通过 
	# nginx -t
	检查下 nginx 配置的语法是否正确，若正确，重启下 nginx.
	启动 uwsgi 服务器:
	$ cd /home/flyer/Practice/项目/
	$ uwsgi -x django_socket.xml
	查看 uwsgi.log 文件是否异常，若无异常，通过 http://域名:8060 访问项目
*** Refer
   http://django-china.cn/topic/101/
   http://django-china.cn/topic/124/
* Tips & Best Practice
** views 中通过 render 向模板中传入 dict 类型数据
   views 中通过 model 获得的是一个 object，可通过如下类似方法把它转化为模板能正
   确处理的 dict 类型:

   # views.py 的某个 view 函数中
   profile		= SomeModel.object.get(some_condition).__dict__
   res			= {'profiles': profile}
   return render(request, 模板, res)

   模板中直接使用 dict 类型的 'profiles' 变量.
** 展示静态页面时用 TemplateView
   如在 urls.py 中配置

   from django.conf.urls import patterns, url
   from django.views.generic import TemplateView

   urlpatterns = patterns('',
       url(r'^about/', TemplateView.as_view(template_name="about.html"))
   )
** url 命名
   这样做是为了避免在 view 或 template 中 hardcode url 路径，这样对 url 的修改仅
   用在 url 的配置文件中进行.

   在主项目的 urls.py 中进行如下类似操作：

   urlpatterns = patterns('',
       url(r'url路径', include(app名.url, name='url名')),
   )

   然后在 app 的 urls.py 中进行如下类似操作：

   urlpatterns = patterns('',
       url(r'url路径', 相应的 view, name='app中url名')
   )

   在 template 中需要使用路径时，进行如下类似操作:

   <a href="{% url 'url名:app中url名' [传给app中url的参数] %}"></a>
