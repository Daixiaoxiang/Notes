* 说明
  该文档针对 django1.5
* 创建相关
  创建一个项目
  $ django-admin.py startproject 项目名

  在一个项目中创建一个 app
  $ python manage.py startapp 应用名
* 修改 ip:port
  $ python manage.py runserver [ip:port]
  $ python manage.py runserver [port]
* 数据库相关
  更新数据库
  $ python manage.py syncdb
  The *syncdb* command runs the SQL from *sqlall* on your database for all apps
  in *INSTALLED_APPS* that don't already exist in your database. *syncdb* can be
  called as often as you like, and it will only ever create the tables that
  don't exist.

  检验 model 构造中是否有错
  $ python manage.py validate

  检查某个 app 的索引信息
  $ python manage.py sqlindexes app名

  查看某个 app 数据库所有相关的
  $ python manage.py sqlall app
* Model
** Basics
   A model is the single, definitive soure of the information about your data.

   Includings three basic things:
   + Each model is a Python class that subclass *django.db.models.Model*
   + Each attribute of the model represents a databases field
   + With all of this, Django gives you an automatically-generated
     database-access API.
** sync 数据库后又修改了 model
   此时需要先删除修改的表，然后再 manage.py sync.
** table name
   Django automatically derives the name of the database table from the name of
   your model class and the app that contains it. A model's database table name
   is constructed by joining the model's "app label" -- the name you used
   in *django-admin.py startapp* -- to the model's class name (converted to
   lower-case), with an underscore between them.

   To override the database table name, use the *db_table* parameter in
   class *Meta*.

   Note:
   + If your database table name is an SQL reserved word, or contains
     characters that aren't allowed in Python variable names -- notably, the
     hyphen -- that's OK. Django quotes column and table names behind the
     scenes.
** Using models
   Do this by editing your settings file and changing the *INSTALLED_APPS*
   setting to add the name of the module that contains your *models.py*.

   Note:
   + When adding new apps to *INSTALLED_APPS*, be sure to run *python manage.py
     syncdb*
** Field
*** 概述
	Each field in your model should be an instance of the appropriate *Field*
	class. Django uses the field class types to determine a few things:
	  + The database column type (e.g. *INTEGER*， *VARCHAR*)
	  + The default HTML widget to use when rendering a form field 
	    (e.g. *<input type="text">*, *<select>*)
	  + The minimal validation requirements, used in Django's admin and in
        automatically-generated forms
*** types used commonly
	提醒：
	+ 笔记中仅包含了我认为我会常用到的，没有列出全部的 field types.

	Bool:
	+ BooleanField(**options)
	  A true/false field.

	  The default form widget for this field is a *CheckboxInput*

	Text:
	+ CharField(max_length=None[, **options])
	  A string field, for small- to large-sized strings.

	  The default form widget for this field is a *TextInput*.
	  
	  The maximum length (in characters) is enforced at the database level and
      in Django's validation.
	+ TextField([**options])
	  A large text field.

	  The default form widget for this field is a *Textarea*.
	+ SlugField([max_length=50, **options])
	  Implies setting *Field.db_index* to *True.*

	Time:
	+ DateField([auto_now=False, auto_now_add=False, **options])
	  A date, represented in Python by a *datetime.date* instances.

	  The default form widget for this field is *TextInput*.
	  The admin adds a JavaScript calendar, and a shortcut
      for *Today*. Includes an additional *invalid_date* error message key.

	  The two useful options:
	  - DateField.auto_now
		Automatically set the field to now _every time the object is saved._
		Useful for "last-modified" timestamps.
	  - DateField.auto_now_add
		Automatically set the field to now _when the object is first created_
		Useful for creation of timestamps.

	  Note:
	  - In Django1.5, setting *auot_now* or *auot_now_add* to *True* will cause
        the field to have *editable=False* and *blank=True* set.
    + DateTimeField([auto_now=False, auto_now_add=False, **options])
	  A date and time, represented in Python by a *datetime.datetime* instance.

	  The default form widget for this field is a single *TextInput*.
	  The admin uses two separate *TextInput* widgets with JavaScript shortcuts.
	+ TimeField([auto_now=False, auto_now_add=False, **options])
	  A time, represented in Python by a *datetime.time* instance.

	  The default form widget for this field is a *TextInput*.
	  The admin adds some JavaScript shortcuts.

    Number:
	+ DecimalField(max_digits=None, decimal_places=None[, **options])
	  A fixed-precision decimal number, represented in Python by a *Decimal*
      instance.

	  The default form widget for this field is a *TextInput*.

	  The two required arguments:
	  - DecimalField.max_digits
		The maximum number of digits allowed in the number. Note that this
        number must be greater than or equal to *decimal_places*
	  - DecimalField.decimal_places
		The number of decimal places to store with the number.
    + FloatField([**options])
	  A floating-point number represented in Python by a *float* instance.

	  The default form widget for this is a *TextInput*.
    + IntegerField([**options])
	  An integer.

	  The default form widget for this field is a *TextInput*.
	+ PositiveIntegerField([**options])
	  Like an *IntegerField*, but must be either positive or zero.
	+ PositiveSmallIntegerField([**options])
	  Like a *PositiveIntegerField*, but only allows values under a certain
      (database-dependent) point. Values up to 32767 are safe in all databases
      supported by Django.
	+ BigIntegerField([**options])
	  A 64 bit integer.

	  The default form widget for this field is a *TextInput*
	+ SmallIntegerField([**options])
	  Like an *IntegerField*, but only allows values under a certain
      (database-dependent) point. Values from -32768 to 32768 are safe in all
      databases supported by Django.

	Email:
    + EmailField([max_length=75, **options])
	  A *CharField* that checks that the value is a valid email address.

	IP:
	+ IPAddressField([**options])
	  An IP address, in string format (e.g. "192.168.0.1").

	  The default form widget for this field is a *TextInput*.
	+ GenericIPAddressField([protocol=both, unpack_ipv4=False, **options])
	  An IPv4 or IPv6 address, in string format. All characters are converted
      to lowercase.

	  The default form widget for this field is a *TextInput*.

	  The two useful options:
	  - GenericIPAddressField.protocol
		Limits valid inputs to the speicific protocol. Accepted values
        are *both* (default), *IPv4* or *IPv6*. Matching is case insensitive.
	  - GenericIPAddressField.unpack_ipv4
		Unpacks IPv4 mapped address like *:ffff:192.0.2.1*. If this option is
        enabled that address would be unpacked to *192.0.2.1*. Can only be used
        when *protocol* is set to *both*.

    URL:
	+ URLField([max_length=200, **options])
	  A *CharField* for a URL.

	  The default form widget for this field is a *TextInput*.

	  The current value of the field will be displayed as a clickable link
      above the input widget.
*** common options
	+ null
	  If *True*, Django will store empty values as *NULL* in the databases.
	  Default is *False*.
	+ blank
	  If *True*, the field is allowed to be blank.
	  
	  Default is *False*.

	  This is different than *null*. *null* is purely _database-related_,
      whereas *blank*  is _validation-realted_. If a field has *blank=True*,
      form validation will allow entry of an empty value. If a field
      has *blank=False*, the field will be required.
	+ choices
	  An iterable of 2-tuples to use as choices for this filed. If this is
      given, the default form widget will be a select box instead of the
      standard text field and will limit choices to the choices given.

	  The first element in each tuple is the value that will be stored in the
      database.
	  The second element will be displayed by the default form widget or in
      a *ModelChoieField*.
	  Given an instance of a model object value for a choices field can be
      accessed using the *get_FOO_display* method.

	  - e.g.
		from django.db import models

		class Person(models.Model):
		    SHIRT_SIZES = (
		        ('S', 'Small'),
		        ('M', 'Medium'),
                ('L', 'Large'),
	        )
		    name = models.CharField(max_length=50)
		    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)

		>>> p = Person(name='Fred Flinstone', shirt_size='L')
		>>> p.save()
		>>> p.shirt_size()    # return 'L'
        >>> p.get_shirt_size_display()    # return 'Large'
    + default
	  The default value for the field. This can be a value or a callable
      object. If callable, it will be called every time a new object is created.
	+ help_text
	  Extra "help" text to be displayed with the form widget.
	  It's useful for documentation even if your field isn't used on a form.
	+ primary_key
	  If *True*, this field is the primary key for the model.
	  If you don't specify *primary_key=True* for any field in your model,
      Django will automatically add an *IntegerField* to hold the primary key.

	  - Note:
		If Django sees you've explicitly set *Field.primary_key*, it won't add
        the automatic *id* column.
    + unique
	  If *True*, this field must be unique throughout the table.
*** verbose field names
	可在定义 field object 时附加一个注释性的字符串.

	Each filed type, except for *ForeignKey*, *ManyToManyField*
	and *OneToOneField*, takes an optional _first positional argument_
	-- a verbose name. If the verboes name isn't given, Django will
	automatically create it using the field's attribute name, converting
	underscores spaces.
	*ForeignKey*, *ManyToManyField* and *OneToOneField* require the first
	argument to be a model class, so use the *verbose_name* keyword argument.

	+ e.g.
	  first_name = models.CharField("person's first name", max_length=30)
	  poll = models.ForeignKey(Poll, verbose_name="the related poll")
*** Field name restrictions
	There're only two restrictions:
	  + A field name cannot be a Python reserved word, because that would
        result in a Python syntax error.
	  + A field name cannot contain more than one underscore in a row, due to
        the way Django's query lookup syntax works.

    Note:
	  + SQL reserved words, such as *join*, *where* or *select*, are allowed as
        model field names, because Django escapes all database table names and
        column names in every underlying SQL query. It uses the quoting syntax
        of your particular database engine.
** Relationships
*** 概述
	The power of relational databases lies in relating tables to each other.
*** Many-to-one relationships
	To define a many-to-one relationship, use *django.db.models.ForeignKey*.
	You use it just like any other *Field* type: by including it as a class
	attribute of your model.

	+ e.g.:
	  Manufacturer 有很多 Car，而 Car 仅对应一个 Manufacturer，即 many-to-one 关
      系，故可在 Car 中使用 models.ForeignKey 表明这种关系.
*** Many-to-many relationships
	To define a many-to-many relationship, use *ManyToManyField*.
	You use it just like any other *Field* type: by including it as a class
	attribute of your model.

	+ e.g.
	  如 "煲仔饭" 里有很多不同的 "配料"，"配料" 又可以对应不同的 "煲仔饭"，即
      many-to-many 关系。一般会在 "配料" class 中使用 *models.ManyToManyField*
      来标明和 "煲仔饭" 的关系.
*** One-to-one relationships
	To define a one-to-one relationship, ues *OneToOneField*.
	You use it just like any other *Field* type: by including it as a class
	attribute of your model.
	
	This is most userful on the primary key of an object when that object
	"entends" another object in some way.

	+ e.g.:
	  Places 有很多属性，如地址等，Restaurant *is a* Place，故 Restaurant 和
      Places 是 one-to-one 关系，可在 Restaurant 中使用 *models.OneToOneField*
      或让 Restaurant 继承 Places 类.
*** 跨 app 关系
	可在一个 app 的 models 中关联另一个 app 的 models，只要正确 import 另一个
	app 的 models 就行.
** Meta options
   Model metadata is "anything but not a field", such as ordering options,
   database table name and so on. None are required, and adding *class Meta* to
   a model is completely optional.

   可用它来控制 *建表* 和 *查表* 时的某些行为.

   + 常用的 attributes 和 methods:
     - app_label
	   If a model exists outside of the standard *models.py* (for instance, if
       the app's models are in submodules of *myapp.models*), the model must
       define which app it is part of:

	   e.g.
	     app_label = 'myapp'
	 - get_latest_by
	   The name of an orderable field in the model, typically
       a *DateField*, *DateTimeField* or *IntegerField*.
	   This specifies the default field to use in your model
       Manager's *latest()* method.

	   e.g.:

	   get_latest_by = "order_date"
	 - ordering
	   The default ordering for the object, for use when obtaining lists of
       objects.
	   This is a tuple or list of strings. Each string is a field name with an
       optional *-* prefix, which indicates descending order. Fields without a
       leading *-* will be ordered ascending. Use the string *?* to order
       randomly.

	   e.g.:
	   
	   ordering = ['-order_date']
	   ordering = ['pub_date']
	   ordering = ['-pub_date', 'author']
	 - unique_together
	   Sets field names that, taken together, must be unique:
	   
	   e.g.:
	       unique_together = (("driver", "restaurant"), )

	   This is a tuple of tuples that must be unique when considered together.
	   It's used in the Django admin and is enforced at the database level
       (i.e., the appropriate *UNIQUE* statements are included in the *CREATE
       TABLE* statement).

	   For convenience, *unique_together* can be a single tuple when dealing
       with a single set of fields:

	   e.g.:
	       unique_together = ("driver", "restaurant")

	   Note:
	   + A *ManyToManyField* cannot be included in *unique_together* (it's not
         clear what that would even mean).
		 If you need to validate uniqueness related to a *ManyToManyField*,
         try using a signal or an explicit *through* model.
	 - index_together
	   Sets of field names that, taken together, are indexed.
	   This list of fields will be indexed together (i.e. the
       appropriate *CREATE INDEX* statement will be issued.)

	   e.g.:

	   index_together = [
	       ['pub_date', 'deadline'],
       ]
	 - verbose_name
	   A human-readable name for the object, singular.
	   If this isn't given, Django will use a munged version of the class name:
       *CamelCase* becomes *camel case*.

	   e.g.:
	   verbose_name = "pizza"
	 - verbose_name_plural
	   The plural name for the object.
	   If this isn't given, Django will use *verbose_name* + "s".
* View
** 功能.
   A view is a callable which takes a request and returns a response.
** function-based views
** class-based views
*** 概述
	Allow you to structure your views and reuse code by harnessing inheritance
	and mixins.

	All views inherit from the *View* class, which handles 
	  + linking the view in the URLs
      + HTTP method dispatching
      + other simple features.

	重要的 method:
	+ class.as_view(*initkwargs*)
	  Returns a callable view that takes a request and returns a response.

	  Any arguments passed to *as_view* will override attributes set on the
      class.

	  It servers as the callable entry point to your class. The *as_view()*
      entry point creates an instance of your class and calls its *dispatch()*
      method. *dispatch()* looks at the request to determine whether it is a
      GET, POST, etc, and relays the request to a matching method if one is
      defined, or raises *HttpResponseNotAllowed* if not.

	  返回的是 HttpResponse object.
*** 与 function-based views 对比优势
	Class-based views do not replace function-based views, but have advantages:
	+ Organization of code related to specific HTTP methods (GET, POST, etc.)
      can be addressed by separate methods instead of conditional branching.
	+ Object oriented techniques such as mixins (multiple inheritance) can be
      used to factor code into reusable components.
*** 两种使用方法
	+ simple usage in your URLconf
	  直接在 url 配置文件中使用三个基本的 view class.
	+ subclassing generic views
	  在 view 文件中写个继承自 view class 的 class，然后在 url 配置中使用该
      class.
*** 三个基础 View Class
	+ *View*
	  class django.views.generic.base.View
	  
	  The master class-based base view. All other class-based views inherit
      from this base class.
	+ *TemplateView*
	  class django.views.generic.base.TemplateView
	  
	  Renders a given template, with the context containing parameters captured
      in the URL.
    + *RedirectView*
	  class django.views.generic.base.RedirectView
	  
	  Redirects to a given URL.
*** Note
	+ You can only inherit from one generic view -- that is, only on parent
      class may inherit from *View* and the rest (if any) should be
      mixins. Trying to inherit from more than one class that inherits
      from *View* won't work as expected.
** generic class-based views
*** 概述
	本质上也是 class-based views，只是把 web 开发过程中使用 class-based views 时
	的一些共性抽象出来，形成可以完成一类任务的 class-based views.

	如果使用 generic views 过程中发现逻辑上处理越来越困难，可重新选择
	function-based views 或 class-based views.
*** class attributes
	+ model
	  指示使用的 model
	+ queryset
	  作用和 *model* 参数一样，指明该 view 处理的 data objects.但它可提供
      比 *model* 参数灵活的方法，如只获取指定的 data objects.

	  e.g.

	  from django.views.generic import DetailView, ListView
	  from books.models import Publisher, Book

	  class PublisherDetail(DetailView):
	      queryset				= Publisher.objects.all()
	      context_object_name	= 'publisher'

	  class BookList(ListView):
	      queryset				= Book.objects.order_by('-publication_date')
	      context_object_name	= 'book_list'

	  class AcmeBookList(ListView):
	      queryset				= Book.objects.filter(publisher__name='Acme Publishing')
	      context_object_name	= 'book_list'
	      template_name			= 'books/acme_list.html'
	+ context_object_name
	  定义模板中使用的与 model 数据相关的名称，修改 generic views 默认的名称 (如
      *ListView* 的派生类会默认使用 *object_list* 或 *model名的小写_list* 作为传
      给 template 的参数)，使可读性更强.
	+ template_name
	  指定使用的 template 名称，虽然 generic class-based views 可以根据一个
      model 来猜测使用的 template 名称，但最好显示指出.
*** object methods
	+ get_context_data(self, **kwargs)
	  - e.g.
		
	    class PublisherDetail(DetailView):
	        model = Publisher

            def get_context_data(self, **kwargs):
	            # call the base implementaion first to get a context
	            context = super(PublisherDetail, self).get_context_data(**kwargs)
	            # Add in a QuerySet of all the books
                context['book_list'] = Book.objects.all()

	            return context
	  - Note
		Generally, *get_context_data* will merge the context data of all parent
        classes with those of the current class. To preserve this behavior in
        your own classes where you want to alter the *context* , you sould be
        sure to call *get_context_data* on the super class. When no two classes
        try to define the same key, this will give the expected
        results. However, if any class attempts to override a key after parent
        classes have set it (after the call to *super*), any children of that
        class will also need to explictly set it after *super* if they want to
        be sure to override all parents.
    + get_queryset()
	  - 作用
		类似 *model* 和 *queryset* 参数，获取该 view class 要处理的 data
        objects.
	  - e.g.
		# urls.py
		from books.views import PublisherBookList

		urlpatterns = patterns('',
		  (r'^books/([\w-]+/$)', PublisherBookList.as_view())
	    )

		# views.py
		from django.shortcuts import get_object_or_404
		from django.views.generic import ListView
		from books.models import Book, Publisher

		class PublisherBookList(ListView):
		    template_name = "books/books_by_publisher.html"
		
		    def get_queryset(self):
		        self.publisher = get_object_or_404(Publisher, name=self.args[0])
		        
		        return Book.objects.filter(publisher=self.publisher)
    + get_object()
	  - 作用
	    It will do some extra work before calling the generic view.
	  - e.g.
		# models.py
		class Author(models.Model):
		    salutation			= models.CharField(max_length=10)
		    name				= models.CharField(max_length=200)
		    email				= models.EmailField()
		    headshot			= models.ImageField(upload_to='autho_headshots')
		    last_accessed		= models.DateTimeField()

		# urls.py
		from books.views import AuthorDetailView

		urlpatterns = patterns('',
		    url(r'^authors/(?P<pk>\d+)/$', AuthorDetailView.as_view()),
	    )

		# views.py
		from django.views.generic import DetailView
		from django.shortcuts import get_object_or_404
		from django.utils import timezone
		from books.models import Author

		class AuthorDetailView(DetailView):
		    queryset = Author.objects.all()
		
		    def get_object(self):
		        # call the superclass
		        object = super(AuthorDetailView, self).get_object()
		        # Record the last accessed date
		        object.last_accessed = timezone.now()
		        object.save()

		        return object
*** generic display views
**** DetailView (working with a single Django object)
	 class django.views.generic.detail.DetailView

	 While this view is executing, *self.object* will contain the object that
	 the view is operating upon.

	 To show the detail of an object, we basically need to do two things:
	   1) look up the object and then,
	   2) make a *TemplateResponse* with a suitable template, and that object
          as context
		  
     To get the object, *DetailView* relies on *SingleObjectMixin*, which
     provides a *get_object* method that figures out the object based on the
     URL of the request (it looks for *pk* and *slug* keyword arguments as
     declared in the URLConf, and looks the object up either from *model*
     attribute on the view, or the *queryset* attribute if that's
     provided). *SingleObjectMixin* also overrides *get_context_data()* , which
     is used across all Django's built in class-based views to supply context
     data for template renders.
**** ListView (working with many Django objects)
	 class django.views.generic.list.ListView

	 While this view is executing, *self.object_list* will contain the list of
	 obejcts (usually, but not necessarily a queryset) that the view is
	 operating upon.

	 The rough work flowchart of *ListView* is:
	   1) we need a (possibly paginated) list of objects, typically
          a *QuerySet*, then
	   2) we need to make a *TemplateResponse* with a suitable template using
          that list of objects.

	 To get the objects, *ListView* uses *MultipleObjectMixin*, which provides
	 both *get_queryset()* and *paginate_queryset()*. Unlike
	 with *SingleObjectMixin*, there's no need to key off parts of the URL to
	 figure out the queryset to work with, so the default just uses
	 the *queryset* or *model* attribute on the view class. A common reason to
	 override *get_queryset()* here would be dynamically vary the objects, such
	 as depending on the current user or to exclude posts in the future for a
	 blog.

	 *MultipleObjectMixin* also overrides *get_context_data()* to include
	 appropriate context variables for pagination (providing dummies if
	 pagination is disabled). It relies on *object_list* being passed in as a
	 keyword argument, which *ListView* arranges for it.
**** Ref
	 + [[https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-display/][django1.5文档]] 不太理解
     + [[https://docs.djangoproject.com/en/1.5/topics/class-based-views/mixins/][Using mixins with class-based views]]
*** Ref
	+ [[https://docs.djangoproject.com/en/1.5/topics/class-based-views/mixins/][Using mixins with class-based views]]
* Form
** 包含 4 种概念
   + Widget
	 A class that corresponds to an HTML form widget, e.g. <input type='text'>
     or <textarea>. This handles rendering of the widgets as HTML.
   + Field
	 A class that is responsible for doing validation, e.g. an 'EmailField'
     that makes sure its data is a valid email address.
   + Form
	 A collection of fields that knowns how to validate itself and display
     itself as HTML.
   + Form Media
	 The CSS and JavaScript resources that are required to render a form.
** 常规需要处理的 3 种类型
   + Initial GET (blank or prepolulated form)
   + POST with invalid data (typically redisplay form with errors)
   + POST with valid data (process the data and typically redirect)
** 可通过 class-based views 实现
*** Basic Usage
	# forms.py
	from django import forms
	
	class ContactForm(forms.Form):
	    name	= forms.CharField()
		message = forms.CharField(widget=forms.Textarea)

		def send_email(self):
		    # send email using the *self.cleaned_data* dict
		    pass

	# views.py
	from myapp.forms import ContactForm
	from django.views.generic.edit import FormView

	class ContactView(FormView):
	    template_name	= 'contact.html'
		form_class		= ContactForm
		successful_url	= '/thanks/'

		def form_valid(self, form):
		    # This method is called when valid form data has been POSTed
		    # The default implementation for *form_valid()* simply redirects
		    # to the *successful_url*
		    # It should return an *HttpResponse*
		    form.send_email()
			return super(ContactForm, self).form_valid(form)
*** Model Forms
	+ 概述
	  The following generic views will automatically create a *ModelForm*, so
      long as they can work out which model class to use:
	  1) If the *model* attribute is given, that model class will be used
	  2) if *get_object()* returns an object, the class of that object will be
         used.
      3) If a *queryset* is given, the model for that queryset will be used.

	  Model form views provide a *form_valid()* implementation that saves the
      model automatically.

	  You don't need to provide a *successful_url* for *CreateView*
      or *UpdateView* -- they will use *get_absolute_url()* on the model object
      if available.

	  If you want to use a custom *ModelForm* (for instance to add extra
      validation), simply set *form_class* attribute on your view. At the same
      time, you must specify the model.
	+ e.g.
	  # models.py
	  from django.core.urlresolvers import reverse
	  form django.db import models

	  class Author(models.Model):
	      name = models.CharField(max_length=200)

	      def get_absolute_url(self):
	          return reverse('author-detail', kwargs={'pk': self.pk,})

	  # views.py
	  from django.views.generic.edit import CreateView, UpdateView, DeleteView
	  from django.core.urlresolves import reverse_lazy
	  from myapp.models import Author

	  class AuthorCreate(CreateView):
	      model			= Author
	      template_name = 'some_template'

	  class AuthorUpdate(UpdateView):
	      model			= Author
	      template_name = 'some_template'

	  class AuthorDelete(DeleteView):
	      model					= Author
	      successful_url		= reverse_lazy('autho-list')
	      template_name			= 'some_template'

	  # urls.py
	  from django.conf.urls import patterns, url
	  from myapp.views import AuthorCreate, AuthorUpdate, AuthorDelete

	  urlpatterns = patterns('',
	      url(r'author/add/$', AuthorCreate.as_view(), name='author_add'),
	      url(r'author/(?P<pk>\d+)/$', AuthorUpdate.as_view(),
              name='author_update'),
	      url(r'author/(?P<pk>\d+)/delete/$', AuthorDelete.as_view(), 
	          name='author_delete'),
	  )
*** Ref
	+ [[https://docs.djangoproject.com/en/1.5/topics/class-based-views/generic-editing/][Form handling with class-based views]]
* 测试
** TDD (Test Driven Development)
   先写测试后写代码，思维过程是 "描述问题-->解决问题".
** 执行
   在 app 的根目录下写完 tests.py 后，在项目的根目录下执行:
   $ python manage.py test app名
** best practice
   + a separate *TestCase* for each model or view
   + a separate test method for each set of conditions you want to test
   + test method names that describe their function
* 部署
** nginx+uwsgi
*** 安装 uwsgi
	$ sudo pip install uwsgi
	
	Note:
	+ 通过 pip 安装，最好不要直接通过系统的包管理器安装，可能会有问题.
*** 测试 uwsgi
	编写 test.py
	
	# test.py
	def application(env, start_response):
	    start_response('200 OK', [('Content-Type', 'text/html')])
		return 'Hello World'

	执行:
	$ uwsgi --http :8001 --wsgi-file test.py
	通过 http://127.0.0.1:8001 访问网页是否有 'Hello World'
*** 仅通过 uwsgi 部署 django
	$ django_admin.py startproject 项目名

	在该项目根目录下添加 django_wsgi.py 文件，

	# django_wsgi.py
	#!/usr/bin/python2.7
	# coding:utf-8

	import os
	import sys
	
	os.environ.setdefault("DJANGO_SETTINGS_MODULE", "项目名.settings")
	
	from django.core.handlers.wsgi import WSGIHandler
	
	application = WSGIHandler()

	部署项目:
	$ uwsgi --http :8000 --chdir /PATH/TO/项目 --module django_wsgi
	把 '/PATH/TO/项目' 改为项目地址，如 '/home/flyer/Practice/项目名'
	通过 http://127.0.0.1:8000 访问项目.
*** 通过 nginx+uwsgi 部署 django
	nginx 处理静态文件，动态文件由 nginx 交给 uwsgi 处理，二者通过 socket 通信.
	假设项目地址 '/home/flyer/Practice/项目名'，nginx 通过 8077 端口与 uwsgi 通信,
	在 '/home/flyer/Practice/项目名/' 根目录下创建 django_wsgi.py(内容同上) 和
	django_socket.xml 文件:

	# django_socket.xml
	<uwsgi>
	    <socket>:8077</socket>
		<chdir>/home/flyer/Practice/项目名/</chdir>
		<module>django_wsgi</module>
		<processes>django_wsgi</processes>
		<daemonize>uwsgi.log</daemonize>
	</uwsgi>

	假设 access.log 和 error.log 放在 '/home/flyer/logs/nginx/' 中，项目中的静态
	文件在 '/home/flyer/Practice/项目/static/' 和 
	'/home/flyer/Practice/项目名/media/' 中，域名端口是 8060.
	修改 nginx.conf (不同的系统该文件地址不一样，搜一下):

	server {
	    listen 8060;
		server_name 域名(本机上可设置为 localhost);

		access_log /home/flyer/logs/nginx/access.log;
		error_log /home/flyer/logs/nginx/error.log;

		location / {
		    include uwsgi_params;
			uwsgi_pass 127.0.0.1:8077;
		}

		error_page 500 502 503 504 /50x.html;
		location = /50x.html {
		    root html;
		}

		location /static/ {
		    alias /home/flyer/Practice/项目/static/;
			index index.html index.htm;
		}

		location /media/ {
		    alias /home/flyer/Practice/项目/media/;
		}
	}

	先通过 
	# nginx -t
	检查下 nginx 配置的语法是否正确，若正确，重启下 nginx.
	启动 uwsgi 服务器:
	$ cd /home/flyer/Practice/项目/
	$ uwsgi -x django_socket.xml
	查看 uwsgi.log 文件是否异常，若无异常，通过 http://域名:8060 访问项目
*** Refer
   http://django-china.cn/topic/101/
   http://django-china.cn/topic/124/
* 一些名词
** slug
   *Slug* is a newspaper term. 
   A slug is short label for something, containing only letters, numbers,
   underscores or hyphens. They're generally used in URLs.
* Tips & Best Practice
** views 中通过 render 向模板中传入 dict 类型数据
   views 中通过 model 获得的是一个 object，可通过如下类似方法把它转化为模板能正
   确处理的 dict 类型:

   # views.py 的某个 view 函数中
   profile		= SomeModel.object.get(some_condition).__dict__
   res			= {'profiles': profile}
   return render(request, 模板, res)

   模板中直接使用 dict 类型的 'profiles' 变量.
** 展示静态页面时用 TemplateView
   如在 urls.py 中配置

   from django.conf.urls import patterns, url
   from django.views.generic import TemplateView

   urlpatterns = patterns('',
       url(r'^about/', TemplateView.as_view(template_name="about.html"))
   )
** url 命名
   这样做是为了避免在 view 或 template 中 hardcode url 路径，这样对 url 的修改仅
   用在 url 的配置文件中进行.

   在主项目的 urls.py 中进行如下类似操作：

   urlpatterns = patterns('',
       url(r'url路径', include(app名.url, name='url名')),
   )

   然后在 app 的 urls.py 中进行如下类似操作：

   urlpatterns = patterns('',
       url(r'url路径', 相应的 view, name='app中url名')
   )

   在 template 中需要使用路径时，进行如下类似操作:

   <a href="{% url 'url名:app中url名' [传给app中url的参数] %}"></a>
