* 说明
  该文档针对 django1.5
* 创建相关
  创建一个项目
  $ django-admin.py startproject 项目名

  在一个项目中创建一个 app
  $ python manage.py startapp 应用名
* 修改 ip:port
  $ python manage.py runserver [ip:port]
  $ python manage.py runserver [port]
* 数据库相关
  更新数据库
  $ python manage.py syncdb
  The *syncdb* command runs the SQL from *sqlall* on your database for all apps
  in *INSTALLED_APPS* that don't already exist in your database. *syncdb* can be
  called as often as you like, and it will only ever create the tables that
  don't exist.

  检验 model 构造中是否有错
  $ python manage.py validate

  检查某个 app 的索引信息
  $ python manage.py sqlindexes app名

  查看某个 app 数据库所有相关的
  $ python manage.py sqlall app
* Model
** sync 数据库后又修改了 model
   此时需要先删除修改的表，然后再 manage.py sync.
** 设置 primary key
   可在 model 的 field 中加参数 "primary_key=True".
* View
** 功能.
   A view is a callable which takes a request and returns a response.
** function-based views
** class-based views
*** 概述
	Allow you to structure your views and reuse code by harnessing inheritance
	and mixins.

	All views inherit from the *View* class, which handles 
	  + linking the view in the URLs
      + HTTP method dispatching
      + other simple features.

	重要的 method:
	+ class.as_view(*initkwargs*)
	  Returns a callable view that takes a request and returns a response.

	  Any arguments passed to *as_view* will override attributes set on the
      class.

	  It servers as the callable entry point to your class. The *as_view()*
      entry point creates an instance of your class and calls its *dispatch()*
      method. *dispatch()* looks at the request to determine whether it is a
      GET, POST, etc, and relays the request to a matching method if one is
      defined, or raises *HttpResponseNotAllowed* if not.

	  返回的是 HttpResponse object.
*** 与 function-based views 对比优势
	Class-based views do not replace function-based views, but have advantages:
	+ Organization of code related to specific HTTP methods (GET, POST, etc.)
      can be addressed by separate methods instead of conditional branching.
	+ Object oriented techniques such as mixins (multiple inheritance) can be
      used to factor code into reusable components.
*** 两种使用方法
	+ simple usage in your URLconf
	  直接在 url 配置文件中使用三个基本的 view class.
	+ subclassing generic views
	  在 view 文件中写个继承自 view class 的 class，然后在 url 配置中使用该
      class.
*** 三个基础 View Class
	+ *View*
	  class django.views.generic.base.View
	  
	  The master class-based base view. All other class-based views inherit
      from this base class.
	+ *TemplateView*
	  class django.views.generic.base.TemplateView
	  
	  Renders a given template, with the context containing parameters captured
      in the URL.
    + *RedirectView*
	  class django.views.generic.base.RedirectView
	  
	  Redirects to a given URL.
*** Note
	+ You can only inherit from one generic view -- that is, only on parent
      class may inherit from *View* and the rest (if any) should be
      mixins. Trying to inherit from more than one class that inherits
      from *View* won't work as expected.
** generic class-based views
*** 概述
	本质上也是 class-based views，只是把 web 开发过程中使用 class-based views 时
	的一些共性抽象出来，形成可以完成一类任务的 class-based views.

	如果使用 generic views 过程中发现逻辑上处理越来越困难，可重新选择
	function-based views 或 class-based views.
*** class attributes
	+ model
	  指示使用的 model
	+ queryset
	  作用和 *model* 参数一样，指明该 view 处理的 data objects.但它可提供
      比 *model* 参数灵活的方法，如只获取指定的 data objects.

	  e.g.

	  from django.views.generic import DetailView, ListView
	  from books.models import Publisher, Book

	  class PublisherDetail(DetailView):
	      queryset				= Publisher.objects.all()
	      context_object_name	= 'publisher'

	  class BookList(ListView):
	      queryset				= Book.objects.order_by('-publication_date')
	      context_object_name	= 'book_list'

	  class AcmeBookList(ListView):
	      queryset				= Book.objects.filter(publisher__name='Acme Publishing')
	      context_object_name	= 'book_list'
	      template_name			= 'books/acme_list.html'
	+ context_object_name
	  定义模板中使用的与 model 数据相关的名称，修改 generic views 默认的名称 (如
      *ListView* 的派生类会默认使用 *object_list* 或 *model名的小写_list* 作为传
      给 template 的参数)，使可读性更强.
	+ template_name
	  指定使用的 template 名称，虽然 generic class-based views 可以根据一个
      model 来猜测使用的 template 名称，但最好显示指出.
*** object methods
	+ get_context_data(self, **kwargs)
	  - e.g.
		
	    class PublisherDetail(DetailView):
	        model = Publisher

            def get_context_data(self, **kwargs):
	            # call the base implementaion first to get a context
	            context = super(PublisherDetail, self).get_context_data(**kwargs)
	            # Add in a QuerySet of all the books
                context['book_list'] = Book.objects.all()

	            return context
	  - Note
		Generally, *get_context_data* will merge the context data of all parent
        classes with those of the current class. To preserve this behavior in
        your own classes where you want to alter the *context* , you sould be
        sure to call *get_context_data* on the super class. When no two classes
        try to define the same key, this will give the expected
        results. However, if any class attempts to override a key after parent
        classes have set it (after the call to *super*), any children of that
        class will also need to explictly set it after *super* if they want to
        be sure to override all parents.
    + get_queryset()
	  - 作用
		类似 *model* 和 *queryset* 参数，获取该 view class 要处理的 data
        objects.
	  - e.g.
		# urls.py
		from books.views import PublisherBookList

		urlpatterns = patterns('',
		  (r'^books/([\w-]+/$)', PublisherBookList.as_view())
	    )

		# views.py
		from django.shortcuts import get_object_or_404
		from django.views.generic import ListView
		from books.models import Book, Publisher

		class PublisherBookList(ListView):
		    template_name = "books/books_by_publisher.html"
		
		    def get_queryset(self):
		        self.publisher = get_object_or_404(Publisher, name=self.args[0])
		        
		        return Book.objects.filter(publisher=self.publisher)
    + get_object()
	  - 作用
	    It will do some extra work before calling the generic view.
	  - e.g.
		# models.py
		class Author(models.Model):
		    salutation			= models.CharField(max_length=10)
		    name				= models.CharField(max_length=200)
		    email				= models.EmailField()
		    headshot			= models.ImageField(upload_to='autho_headshots')
		    last_accessed		= models.DateTimeField()

		# urls.py
		from books.views import AuthorDetailView

		urlpatterns = patterns('',
		    url(r'^authors/(?P<pk>\d+)/$', AuthorDetailView.as_view()),
	    )

		# views.py
		from django.views.generic import DetailView
		from django.shortcuts import get_object_or_404
		from django.utils import timezone
		from books.models import Author

		class AuthorDetailView(DetailView):
		    queryset = Author.objects.all()
		
		    def get_object(self):
		        # call the superclass
		        object = super(AuthorDetailView, self).get_object()
		        # Record the last accessed date
		        object.last_accessed = timezone.now()
		        object.save()

		        return object
*** generic display views
**** DetailView (working with a single Django object)
	 class django.views.generic.detail.DetailView

	 While this view is executing, *self.object* will contain the object that
	 the view is operating upon.

	 To show the detail of an object, we basically need to do two things:
	   1) look up the object and then,
	   2) make a *TemplateResponse* with a suitable template, and that object
          as context
		  
     To get the object, *DetailView* relies on *SingleObjectMixin*, which
     provides a *get_object* method that figures out the object based on the
     URL of the request (it looks for *pk* and *slug* keyword arguments as
     declared in the URLConf, and looks the object up either from *model*
     attribute on the view, or the *queryset* attribute if that's
     provided). *SingleObjectMixin* also overrides *get_context_data()* , which
     is used across all Django's built in class-based views to supply context
     data for template renders.
**** ListView (working with many Django objects)
	 class django.views.generic.list.ListView

	 While this view is executing, *self.object_list* will contain the list of
	 obejcts (usually, but not necessarily a queryset) that the view is
	 operating upon.

	 The rough work flowchart of *ListView* is:
	   1) we need a (possibly paginated) list of objects, typically
          a *QuerySet*, then
	   2) we need to make a *TemplateResponse* with a suitable template using
          that list of objects.

	 To get the objects, *ListView* uses *MultipleObjectMixin*, which provides
	 both *get_queryset()* and *paginate_queryset()*. Unlike
	 with *SingleObjectMixin*, there's no need to key off parts of the URL to
	 figure out the queryset to work with, so the default just uses
	 the *queryset* or *model* attribute on the view class. A common reason to
	 override *get_queryset()* here would be dynamically vary the objects, such
	 as depending on the current user or to exclude posts in the future for a
	 blog.

	 *MultipleObjectMixin* also overrides *get_context_data()* to include
	 appropriate context variables for pagination (providing dummies if
	 pagination is disabled). It relies on *object_list* being passed in as a
	 keyword argument, which *ListView* arranges for it.
**** Ref
	 + [[https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-display/][django1.5文档]] 不太理解
     + [[https://docs.djangoproject.com/en/1.5/topics/class-based-views/mixins/][Using mixins with class-based views]]
*** Ref
	+ [[https://docs.djangoproject.com/en/1.5/topics/class-based-views/mixins/][Using mixins with class-based views]]
* Form
** 包含 4 种概念
   + Widget
	 A class that corresponds to an HTML form widget, e.g. <input type='text'>
     or <textarea>. This handles rendering of the widgets as HTML.
   + Field
	 A class that is responsible for doing validation, e.g. an 'EmailField'
     that makes sure its data is a valid email address.
   + Form
	 A collection of fields that knowns how to validate itself and display
     itself as HTML.
   + Form Media
	 The CSS and JavaScript resources that are required to render a form.
** 常规需要处理的 3 种类型
   + Initial GET (blank or prepolulated form)
   + POST with invalid data (typically redisplay form with errors)
   + POST with valid data (process the data and typically redirect)
** 可通过 class-based views 实现
*** Basic Usage
	# forms.py
	from django import forms
	
	class ContactForm(forms.Form):
	    name	= forms.CharField()
		message = forms.CharField(widget=forms.Textarea)

		def send_email(self):
		    # send email using the *self.cleaned_data* dict
		    pass

	# views.py
	from myapp.forms import ContactForm
	from django.views.generic.edit import FormView

	class ContactView(FormView):
	    template_name	= 'contact.html'
		form_class		= ContactForm
		successful_url	= '/thanks/'

		def form_valid(self, form):
		    # This method is called when valid form data has been POSTed
		    # The default implementation for *form_valid()* simply redirects
		    # to the *successful_url*
		    # It should return an *HttpResponse*
		    form.send_email()
			return super(ContactForm, self).form_valid(form)
*** Model Forms
	+ 概述
	  The following generic views will automatically create a *ModelForm*, so
      long as they can work out which model class to use:
	  1) If the *model* attribute is given, that model class will be used
	  2) if *get_object()* returns an object, the class of that object will be
         used.
      3) If a *queryset* is given, the model for that queryset will be used.

	  Model form views provide a *form_valid()* implementation that saves the
      model automatically.

	  You don't need to provide a *successful_url* for *CreateView*
      or *UpdateView* -- they will use *get_absolute_url()* on the model object
      if available.

	  If you want to use a custom *ModelForm* (for instance to add extra
      validation), simply set *form_class* attribute on your view. At the same
      time, you must specify the model.
	+ e.g.
	  # models.py
	  from django.core.urlresolvers import reverse
	  form django.db import models

	  class Author(models.Model):
	      name = models.CharField(max_length=200)

	      def get_absolute_url(self):
	          return reverse('author-detail', kwargs={'pk': self.pk,})

	  # views.py
	  from django.views.generic.edit import CreateView, UpdateView, DeleteView
	  from django.core.urlresolves import reverse_lazy
	  from myapp.models import Author

	  class AuthorCreate(CreateView):
	      model			= Author
	      template_name = 'some_template'

	  class AuthorUpdate(UpdateView):
	      model			= Author
	      template_name = 'some_template'

	  class AuthorDelete(DeleteView):
	      model					= Author
	      successful_url		= reverse_lazy('autho-list')
	      template_name			= 'some_template'

	  # urls.py
	  from django.conf.urls import patterns, url
	  from myapp.views import AuthorCreate, AuthorUpdate, AuthorDelete

	  urlpatterns = patterns('',
	      url(r'author/add/$', AuthorCreate.as_view(), name='author_add'),
	      url(r'author/(?P<pk>\d+)/$', AuthorUpdate.as_view(),
              name='author_update'),
	      url(r'author/(?P<pk>\d+)/delete/$', AuthorDelete.as_view(), 
	          name='author_delete'),
	  )
*** Ref
	+ [[https://docs.djangoproject.com/en/1.5/topics/class-based-views/generic-editing/][Form handling with class-based views]]
* 测试
** TDD (Test Driven Development)
   先写测试后写代码，思维过程是 "描述问题-->解决问题".
** 执行
   在 app 的根目录下写完 tests.py 后，在项目的根目录下执行:
   $ python manage.py test app名
** best practice
   + a separate *TestCase* for each model or view
   + a separate test method for each set of conditions you want to test
   + test method names that describe their function
* 部署
** nginx+uwsgi
*** 安装 uwsgi
	$ sudo pip install uwsgi
	
	Note:
	+ 通过 pip 安装，最好不要直接通过系统的包管理器安装，可能会有问题.
*** 测试 uwsgi
	编写 test.py
	
	# test.py
	def application(env, start_response):
	    start_response('200 OK', [('Content-Type', 'text/html')])
		return 'Hello World'

	执行:
	$ uwsgi --http :8001 --wsgi-file test.py
	通过 http://127.0.0.1:8001 访问网页是否有 'Hello World'
*** 仅通过 uwsgi 部署 django
	$ django_admin.py startproject 项目名

	在该项目根目录下添加 django_wsgi.py 文件，

	# django_wsgi.py
	#!/usr/bin/python2.7
	# coding:utf-8

	import os
	import sys
	
	os.environ.setdefault("DJANGO_SETTINGS_MODULE", "项目名.settings")
	
	from django.core.handlers.wsgi import WSGIHandler
	
	application = WSGIHandler()

	部署项目:
	$ uwsgi --http :8000 --chdir /PATH/TO/项目 --module django_wsgi
	把 '/PATH/TO/项目' 改为项目地址，如 '/home/flyer/Practice/项目名'
	通过 http://127.0.0.1:8000 访问项目.
*** 通过 nginx+uwsgi 部署 django
	nginx 处理静态文件，动态文件由 nginx 交给 uwsgi 处理，二者通过 socket 通信.
	假设项目地址 '/home/flyer/Practice/项目名'，nginx 通过 8077 端口与 uwsgi 通信,
	在 '/home/flyer/Practice/项目名/' 根目录下创建 django_wsgi.py(内容同上) 和
	django_socket.xml 文件:

	# django_socket.xml
	<uwsgi>
	    <socket>:8077</socket>
		<chdir>/home/flyer/Practice/项目名/</chdir>
		<module>django_wsgi</module>
		<processes>django_wsgi</processes>
		<daemonize>uwsgi.log</daemonize>
	</uwsgi>

	假设 access.log 和 error.log 放在 '/home/flyer/logs/nginx/' 中，项目中的静态
	文件在 '/home/flyer/Practice/项目/static/' 和 
	'/home/flyer/Practice/项目名/media/' 中，域名端口是 8060.
	修改 nginx.conf (不同的系统该文件地址不一样，搜一下):

	server {
	    listen 8060;
		server_name 域名(本机上可设置为 localhost);

		access_log /home/flyer/logs/nginx/access.log;
		error_log /home/flyer/logs/nginx/error.log;

		location / {
		    include uwsgi_params;
			uwsgi_pass 127.0.0.1:8077;
		}

		error_page 500 502 503 504 /50x.html;
		location = /50x.html {
		    root html;
		}

		location /static/ {
		    alias /home/flyer/Practice/项目/static/;
			index index.html index.htm;
		}

		location /media/ {
		    alias /home/flyer/Practice/项目/media/;
		}
	}

	先通过 
	# nginx -t
	检查下 nginx 配置的语法是否正确，若正确，重启下 nginx.
	启动 uwsgi 服务器:
	$ cd /home/flyer/Practice/项目/
	$ uwsgi -x django_socket.xml
	查看 uwsgi.log 文件是否异常，若无异常，通过 http://域名:8060 访问项目
*** Refer
   http://django-china.cn/topic/101/
   http://django-china.cn/topic/124/
* Tips & Best Practice
** views 中通过 render 向模板中传入 dict 类型数据
   views 中通过 model 获得的是一个 object，可通过如下类似方法把它转化为模板能正
   确处理的 dict 类型:

   # views.py 的某个 view 函数中
   profile		= SomeModel.object.get(some_condition).__dict__
   res			= {'profiles': profile}
   return render(request, 模板, res)

   模板中直接使用 dict 类型的 'profiles' 变量.
** 展示静态页面时用 TemplateView
   如在 urls.py 中配置

   from django.conf.urls import patterns, url
   from django.views.generic import TemplateView

   urlpatterns = patterns('',
       url(r'^about/', TemplateView.as_view(template_name="about.html"))
   )
** url 命名
   这样做是为了避免在 view 或 template 中 hardcode url 路径，这样对 url 的修改仅
   用在 url 的配置文件中进行.

   在主项目的 urls.py 中进行如下类似操作：

   urlpatterns = patterns('',
       url(r'url路径', include(app名.url, name='url名')),
   )

   然后在 app 的 urls.py 中进行如下类似操作：

   urlpatterns = patterns('',
       url(r'url路径', 相应的 view, name='app中url名')
   )

   在 template 中需要使用路径时，进行如下类似操作:

   <a href="{% url 'url名:app中url名' [传给app中url的参数] %}"></a>
