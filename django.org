* 说明
  该文档针对 django1.5
* 创建相关
  创建一个项目
  $ django-admin.py startproject 项目名

  在一个项目中创建一个 app
  $ python manage.py startapp 应用名
* 修改 ip:port
  $ python manage.py runserver [ip:port]
  $ python manage.py runserver [port]
* 数据库相关
  更新数据库
  $ python manage.py syncdb
  The *syncdb* command runs the SQL from *sqlall* on your database for all apps
  in *INSTALLED_APPS* that don't already exist in your database. *syncdb* can be
  called as often as you like, and it will only ever create the tables that
  don't exist.

  检验 model 构造中是否有错
  $ python manage.py validate

  检查某个 app 的索引信息
  $ python manage.py sqlindexes app名

  查看某个 app 数据库所有相关的
  $ python manage.py sqlall app
* Model
** Basics
   A model is the single, definitive soure of the information about your data.

   Includings three basic things:
   + Each model is a Python class that subclass *django.db.models.Model*
   + Each attribute of the model represents a databases field
   + With all of this, Django gives you an automatically-generated
     database-access API.
** sync 数据库后又修改了 model
   此时需要先删除修改的表，然后再 manage.py sync.
** table name
   Django automatically derives the name of the database table from the name of
   your model class and the app that contains it. A model's database table name
   is constructed by joining the model's "app label" -- the name you used
   in *django-admin.py startapp* -- to the model's class name (converted to
   lower-case), with an underscore between them.

   To override the database table name, use the *db_table* parameter in
   class *Meta*.

   Note:
   + If your database table name is an SQL reserved word, or contains
     characters that aren't allowed in Python variable names -- notably, the
     hyphen -- that's OK. Django quotes column and table names behind the
     scenes.
** Using models
   Do this by editing your settings file and changing the *INSTALLED_APPS*
   setting to add the name of the module that contains your *models.py*.

   Note:
   + When adding new apps to *INSTALLED_APPS*, be sure to run *python manage.py
     syncdb*
** Field
*** 概述
	Each field in your model should be an instance of the appropriate *Field*
	class. Django uses the field class types to determine a few things:
	  + The database column type (e.g. *INTEGER*， *VARCHAR*)
	  + The default HTML widget to use when rendering a form field 
	    (e.g. *<input type="text">*, *<select>*)
	  + The minimal validation requirements, used in Django's admin and in
        automatically-generated forms
*** types used commonly
	提醒：
	+ 笔记中仅包含了我认为我会常用到的，没有列出全部的 field types.

	Bool:
	+ BooleanField(**options)
	  A true/false field.

	  The default form widget for this field is a *CheckboxInput*

	Text:
	+ CharField(max_length=None[, **options])
	  A string field, for small- to large-sized strings.

	  The default form widget for this field is a *TextInput*.
	  
	  The maximum length (in characters) is enforced at the database level and
      in Django's validation.
	+ TextField([**options])
	  A large text field.

	  The default form widget for this field is a *Textarea*.
	+ SlugField([max_length=50, **options])
	  Implies setting *Field.db_index* to *True.*

	Time:
	+ DateField([auto_now=False, auto_now_add=False, **options])
	  A date, represented in Python by a *datetime.date* instances.

	  The default form widget for this field is *TextInput*.
	  The admin adds a JavaScript calendar, and a shortcut
      for *Today*. Includes an additional *invalid_date* error message key.

	  The two useful options:
	  - DateField.auto_now
		Automatically set the field to now _every time the object is saved._
		Useful for "last-modified" timestamps.
	  - DateField.auto_now_add
		Automatically set the field to now _when the object is first created_
		Useful for creation of timestamps.

	  Note:
	  - In Django1.5, setting *auot_now* or *auot_now_add* to *True* will cause
        the field to have *editable=False* and *blank=True* set.
    + DateTimeField([auto_now=False, auto_now_add=False, **options])
	  A date and time, represented in Python by a *datetime.datetime* instance.

	  The default form widget for this field is a single *TextInput*.
	  The admin uses two separate *TextInput* widgets with JavaScript shortcuts.
	+ TimeField([auto_now=False, auto_now_add=False, **options])
	  A time, represented in Python by a *datetime.time* instance.

	  The default form widget for this field is a *TextInput*.
	  The admin adds some JavaScript shortcuts.

    Number:
	+ DecimalField(max_digits=None, decimal_places=None[, **options])
	  A fixed-precision decimal number, represented in Python by a *Decimal*
      instance.

	  The default form widget for this field is a *TextInput*.

	  The two required arguments:
	  - DecimalField.max_digits
		The maximum number of digits allowed in the number. Note that this
        number must be greater than or equal to *decimal_places*
	  - DecimalField.decimal_places
		The number of decimal places to store with the number.
    + FloatField([**options])
	  A floating-point number represented in Python by a *float* instance.

	  The default form widget for this is a *TextInput*.
    + IntegerField([**options])
	  An integer.

	  The default form widget for this field is a *TextInput*.
	+ PositiveIntegerField([**options])
	  Like an *IntegerField*, but must be either positive or zero.
	+ PositiveSmallIntegerField([**options])
	  Like a *PositiveIntegerField*, but only allows values under a certain
      (database-dependent) point. Values up to 32767 are safe in all databases
      supported by Django.
	+ BigIntegerField([**options])
	  A 64 bit integer.

	  The default form widget for this field is a *TextInput*
	+ SmallIntegerField([**options])
	  Like an *IntegerField*, but only allows values under a certain
      (database-dependent) point. Values from -32768 to 32768 are safe in all
      databases supported by Django.

	Email:
    + EmailField([max_length=75, **options])
	  A *CharField* that checks that the value is a valid email address.

	IP:
	+ IPAddressField([**options])
	  An IP address, in string format (e.g. "192.168.0.1").

	  The default form widget for this field is a *TextInput*.
	+ GenericIPAddressField([protocol=both, unpack_ipv4=False, **options])
	  An IPv4 or IPv6 address, in string format. All characters are converted
      to lowercase.

	  The default form widget for this field is a *TextInput*.

	  The two useful options:
	  - GenericIPAddressField.protocol
		Limits valid inputs to the speicific protocol. Accepted values
        are *both* (default), *IPv4* or *IPv6*. Matching is case insensitive.
	  - GenericIPAddressField.unpack_ipv4
		Unpacks IPv4 mapped address like *:ffff:192.0.2.1*. If this option is
        enabled that address would be unpacked to *192.0.2.1*. Can only be used
        when *protocol* is set to *both*.

    URL:
	+ URLField([max_length=200, **options])
	  A *CharField* for a URL.

	  The default form widget for this field is a *TextInput*.

	  The current value of the field will be displayed as a clickable link
      above the input widget.
*** common options
	+ null
	  If *True*, Django will store empty values as *NULL* in the databases.
	  Default is *False*.
	+ blank
	  If *True*, the field is allowed to be blank.
	  
	  Default is *False*.

	  This is different than *null*. *null* is purely _database-related_,
      whereas *blank*  is _validation-realted_. If a field has *blank=True*,
      form validation will allow entry of an empty value. If a field
      has *blank=False*, the field will be required.
	+ choices
	  An iterable of 2-tuples to use as choices for this filed. If this is
      given, the default form widget will be a select box instead of the
      standard text field and will limit choices to the choices given.

	  The first element in each tuple is the value that will be stored in the
      database.
	  The second element will be displayed by the default form widget or in
      a *ModelChoieField*.
	  Given an instance of a model object value for a choices field can be
      accessed using the *get_FOO_display* method.

	  - e.g.
		from django.db import models

		class Person(models.Model):
		    SHIRT_SIZES = (
		        ('S', 'Small'),
		        ('M', 'Medium'),
                ('L', 'Large'),
	        )
		    name = models.CharField(max_length=50)
		    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)

		>>> p = Person(name='Fred Flinstone', shirt_size='L')
		>>> p.save()
		>>> p.shirt_size()    # return 'L'
        >>> p.get_shirt_size_display()    # return 'Large'
    + default
	  The default value for the field. This can be a value or a callable
      object. If callable, it will be called every time a new object is created.
	+ help_text
	  Extra "help" text to be displayed with the form widget.
	  It's useful for documentation even if your field isn't used on a form.
	+ primary_key
	  If *True*, this field is the primary key for the model.
	  If you don't specify *primary_key=True* for any field in your model,
      Django will automatically add an *IntegerField* to hold the primary key.

	  - Note:
		If Django sees you've explicitly set *Field.primary_key*, it won't add
        the automatic *id* column.
    + unique
	  If *True*, this field must be unique throughout the table.
*** verbose field names
	可在定义 field object 时附加一个注释性的字符串.

	Each filed type, except for *ForeignKey*, *ManyToManyField*
	and *OneToOneField*, takes an optional _first positional argument_
	-- a verbose name. If the verboes name isn't given, Django will
	automatically create it using the field's attribute name, converting
	underscores spaces.
	*ForeignKey*, *ManyToManyField* and *OneToOneField* require the first
	argument to be a model class, so use the *verbose_name* keyword argument.

	+ e.g.
	  first_name = models.CharField("person's first name", max_length=30)
	  poll = models.ForeignKey(Poll, verbose_name="the related poll")
*** Field name restrictions
	There're only two restrictions:
	  + A field name cannot be a Python reserved word, because that would
        result in a Python syntax error.
	  + A field name cannot contain more than one underscore in a row, due to
        the way Django's query lookup syntax works.

    Note:
	  + SQL reserved words, such as *join*, *where* or *select*, are allowed as
        model field names, because Django escapes all database table names and
        column names in every underlying SQL query. It uses the quoting syntax
        of your particular database engine.
** Relationships
*** 概述
	The power of relational databases lies in relating tables to each other.
*** Many-to-one relationships
	To define a many-to-one relationship, use *django.db.models.ForeignKey*.
	You use it just like any other *Field* type: by including it as a class
	attribute of your model.

	+ e.g.:
	  Manufacturer 有很多 Car，而 Car 仅对应一个 Manufacturer，即 many-to-one 关
      系，故可在 Car 中使用 models.ForeignKey 表明这种关系.
*** Many-to-many relationships
	To define a many-to-many relationship, use *ManyToManyField*.
	You use it just like any other *Field* type: by including it as a class
	attribute of your model.

	+ e.g.
	  如 "煲仔饭" 里有很多不同的 "配料"，"配料" 又可以对应不同的 "煲仔饭"，即
      many-to-many 关系。一般会在 "配料" class 中使用 *models.ManyToManyField*
      来标明和 "煲仔饭" 的关系.
*** One-to-one relationships
	To define a one-to-one relationship, ues *OneToOneField*.
	You use it just like any other *Field* type: by including it as a class
	attribute of your model.
	
	This is most userful on the primary key of an object when that object
	"entends" another object in some way.

	+ e.g.:
	  Places 有很多属性，如地址等，Restaurant *is a* Place，故 Restaurant 和
      Places 是 one-to-one 关系，可在 Restaurant 中使用 *models.OneToOneField*
      或让 Restaurant 继承 Places 类.
*** 跨 app 关系
	可在一个 app 的 models 中关联另一个 app 的 models，只要正确 import 另一个
	app 的 models 就行.
** Meta options
   Model metadata is "anything but not a field", such as ordering options,
   database table name and so on. None are required, and adding *class Meta* to
   a model is completely optional.

   可用它来控制 *建表* 和 *查表* 时的某些行为.

   + 常用的 attributes 和 methods:
     - app_label
	   If a model exists outside of the standard *models.py* (for instance, if
       the app's models are in submodules of *myapp.models*), the model must
       define which app it is part of:

	   e.g.
	     app_label = 'myapp'
	 - db_table
	   The name of the database table to use for the model.
	 - get_latest_by
	   The name of an orderable field in the model, typically
       a *DateField*, *DateTimeField* or *IntegerField*.
	   This specifies the default field to use in your model
       Manager's *latest()* method.

	   e.g.:

	   get_latest_by = "order_date"
	 - ordering
	   The default ordering for the object, for use when obtaining lists of
       objects.
	   This is a tuple or list of strings. Each string is a field name with an
       optional *-* prefix, which indicates descending order. Fields without a
       leading *-* will be ordered ascending. Use the string *?* to order
       randomly.

	   e.g.:
	   
	   ordering = ['-order_date']
	   ordering = ['pub_date']
	   ordering = ['-pub_date', 'author']
	 - unique_together
	   Sets field names that, taken together, must be unique:
	   
	   e.g.:
	       unique_together = (("driver", "restaurant"), )

	   This is a tuple of tuples that must be unique when considered together.
	   It's used in the Django admin and is enforced at the database level
       (i.e., the appropriate *UNIQUE* statements are included in the *CREATE
       TABLE* statement).

	   For convenience, *unique_together* can be a single tuple when dealing
       with a single set of fields:

	   e.g.:
	       unique_together = ("driver", "restaurant")

	   Note:
	   + A *ManyToManyField* cannot be included in *unique_together* (it's not
         clear what that would even mean).
		 If you need to validate uniqueness related to a *ManyToManyField*,
         try using a signal or an explicit *through* model.
	 - index_together
	   Sets of field names that, taken together, are indexed.
	   This list of fields will be indexed together (i.e. the
       appropriate *CREATE INDEX* statement will be issued.)

	   e.g.:

	   index_together = [
	       ['pub_date', 'deadline'],
       ]
	 - verbose_name
	   A human-readable name for the object, singular.
	   If this isn't given, Django will use a munged version of the class name:
       *CamelCase* becomes *camel case*.

	   e.g.:
	   verbose_name = "pizza"
	 - verbose_name_plural
	   The plural name for the object.
	   If this isn't given, Django will use *verbose_name* + "s".
** Model methods
*** 与 models.Manager 的区分
	+ Model methods are *row-level* functionality to your objects and they
      should act on a particular model instance.
	  This a valuable technique for keeping business logic in one place -- the
      model.
	+ models.Manager methods are intended to do *table-wide*
      things. A *Manager* is the interface through which database query
      operations are provided to Django models.

	Ref:
	  + [[Managers][Managers]]
	  + [[https://docs.djangoproject.com/en/1.5/ref/models/instances/#model-instance-methods][model-instance-methods]]
*** 常用的 method
	+ __unicode__(self)
	  A Python "magic method" that returns a unicode "representation" of any
      object. This is what Python and Django will use whenever a model instance
      needs to be coerced and displayed as a plain string. Most notably, this
      happens when you display an object in an interactive console or in the
      admin.
	+ get_absoulute_url()
	  This tells Django how to calculate the URL for an object. Django uses
      this in its admin interface, and any time it needs to figure out a URL
      for an object.

	  Any object that has a URL that uniquely identifies it should define this
      method.
** Overriding predefined model methods
   Often you'll want to change the way *save()* and *delete()* work.
   A classic use-case for overriding the built-in methods is if you want
   something to happen whenever you save an object.

   e.g.:
     class Blog(models.Model):
	     name = models.CharField(max_length=100)
		 tagline = models.TextField()

		 def save(self, *args, **kwargs):
		     do_something()
			 # call the 'real' save() method
			 super(Blog, self).save(*args, **kwargs)
			 do_something_else()

	  class Blog(models.Model):
	      name = models.CharField(max_length=100)
		  tagline = models.TextField()

		  def save(self, *args, **kwargs):
		      if self.name == "Yoko Ono's blog":
			      return
			  else:
			      # call the 'real' save() method
			      super(Blog, self).save(*args, **kwargs)
** 数据库操作
*** 概述
	常见的是 CRUD，即 create, retrieve, update, delete，即 "增删改查".

	要区分:
	  + table-level operations
	  + record-level operations
*** save
	对 model 或 field 添加或更新后，要执行 *save()* 操作进行生效。

	对两类表关系的添加、更新:
	+ OneToOne (即 *ForeignKey*)
	  Updating a *ForeignKey* field works exactly the same way as saving a
      normal field.
	  
	  e.g.:
	  >>> from blog.models import Entry, Blog
	  >>> entry = Entry.objects.get(pk=1)
	  >>> cheese_blog = Blog.objects.get(name="Cheddar Talk")
	  >>> entry.blog = cheese_blog
	  >>> entry.save()
	+ ManyToMany
	  Use the *add()* method on the field to add a record to the relation.
	  
	  e.g.
	  # 添加一个
	  >>> from blog.models import Author
	  >>> joe = Author.objects.create(name="joe")
	  >>> entry.authors.add(joe)
	  
	  # 添加多个
	  >>> john = Author.objects.create(name="John")
	  >>> paul = Author.objects.create(name="Paul")
	  >>> george = Author.objects.create(name="George")
	  >>> ringo = Author.objects.create(name="Ringo")
	  >>> entry.authors.add(john, paul, george, ringo)
*** retrieve
	To retrieve objects from your database, construct a *QuerySet* via
	a *Manager* on your model class.

	A *QuerySet* equates to a *SELECT* statement, and a filter is a limiting
	clause such as *WHERE* or *LIMIT*.
	
	You get a *QuerySet* by using your model's *Manager*. Each model has at
	least one *Manager*, and it's called *objects* by default. Access it
	directly via the model class.

	*Managers* are accessible only via model classes, rather than from model
	instances, to enforce a separation between *table-level* operations
	and *record-level* operations.

	+ retrieving all objects
	  >>> all_entries = model名.objects.all()
	+ retrieving specific objects with filters
	  There're two most common ways:
	  - *filter(**kwargs)*
		Return a new *QuerySet* containing objects that match the given lookup
        parameters.
	  - *exclude(**kwargs)*
		Returns a new *QuerySet* containing objects that do not match the given
        lookup parameters

	  The result of refining a *QuerySet* is itself a *QuerySet*.
		
	  You can chain the filters together, like:
	  >>> model名.objects.filter(条件).exclude(条件).filter(条件)
	+ retrieving a single object with *get*
	  *filter()* will always give you a *QuerySet*, even if only a single
      object matches the query -- in this case, it will be a *QuerySet*
      containing a single element.
	  If you know there is only one object that matches your query, you can use
      the *get()* method on a *Manager* which returns the object directly.
	  You can use any query expression with *get()*, just like with *filter()*.

	  There may be two excepitons while using *get()*:
	  - If there are no results that match the query, *get()* will raise
        a *DoesNotExist* exception. This exception is an attribute of the model
        class that the query is being performed on.
	  - If more than one item matches the *get()*, Django will complain. In
        this case, it will raise *MultipleObjectsReturned*, which again is an
        attribute of the model class itself.
    + limiting QuerySets
	  This is the equivalent of SQL's *LIMIT* and *OFFSET* clauses.

	  e.g.:
	  >>> Entry.objects.all()[:5]
	  >>> Entry.objects.all()[5:10]
	  >>> Entry.objects.all()[:10:2]
	  >>> Entry.objects.order_by('headline')[0]
	  # the above is equal to the following
	  >>> Entry.objects.order_by('headline')[0:1].get()
	  (In the last two exmaples of the above, the first will raise *IndexError*
      while the second will raise *DoesNotExist* if no objects match the given
      criteria.)
	  
	  Note:
	  - Negative indexing (i.e. *Entry.objects.all()[-1]*) is not supported.
    + field lookups
	  Field lookups are how you specify the meat of an SQL *WHERE*
      clause. They're specified as keyword arguments to the *QuerySet*
      methods *filter()*, *exclude()* and *get()*.
	  
	  Basic lookups keyword arguments take the form *field__lookuptype=value*
      (that's a double-underscore).

	  If you pass an invalid keyword argument, a lookup function will
      raise *TypeError*.

	Each time you refine a *QuerySet*, you get a brand-new *QuerySet* that is
	in no way bound to the previous *QuerySet*.即每次查询时都会重新查询数据库.

	*QuerySet* are lazy -- the act of creating a *QuerySet* doesn't involve any
	database activity. You can stack filters together all day long and Django
	won't actually run the query until the *QuerySet* is evaluted.
*** lookup types commonly used
	+ exact
	  An *exact* match. If you don't provide a lookup type -- that is, if your
      keyword argument doesn't contain a double underscore -- the lookup type
      is assumed to be *exact*

	  e.g.:
	  >>> Blog.objects.get(id__exact=14)
	  >>> Blog.objects.get(id=14)
	+ iexact
	  A case-insensitive match.

	  e.g.:
	  >>> Blog.objects.get(name__iexact="beatles blog")
    + contains
	  Case-sensitive containment test, responding to the *LIKE* in SQL
      statements.
	  
	  e.g.:
	  >>> Entry.objects.get(headline__contains="Lennon")
	+ icontains
	  Case-insensitive containment test.

	  >>> Entry.objects.get(headline__icontains="Lennon")
	+ startswith/endswith
	  Starts-with and ends-with search, which are case-sensitive.
    + istartswith/iendswith
	  Starts-with and ends-with search, which are case-insensitive.
*** lookups that span relationships
	Django offers a powerful and intuitive way to *follow* relationships in
	lookups, taking care of the SQL *JOIN* for you automatically, behind the
	scenes. To span a relationship, just ues the field name of related fields
	accross models, separated by double underscores, until you get to the field
	you want. This spanning can be as deep as you'd like.
	It works backwards, too. To refer to a "reverse" relationship, just use the
	lowercase name of the model.
*** filters can reference fields on the model using *class F*
	Django provides the *F() expression* to allow comparsions that could
	compare the value of a model field with another field on the same model.
	Instance of *F()* act as a reference to a model field within a query. These
	references can then be used in query filters to compare the values of two
	different fields on the same model instance.
	e.g.:
	>>> from django.db.models import F
	>>> Entry.objects.filter(n_comments__gt=F('n_pingbacks'))
	
	Django supports the use of addition, subtraction, multiplication, division
	and modulo arithmetic with *F()* objects, both with constants and with
	other *F()* objects.
	e.g.:
	>>> Entry.objects.filter(n_comments__gt=F('n_pingbacks')*2)
	>>> Entry.objects.filter(rating__lt=F('n_comments') + F('n_pingbacks'))

	You can alos use the double underscore notation to span relationships in
	an *F()* object. An *F()* object with a double underscore will introduce
	any joins needed to access the related object.
	e.g.:
	>>> Entry.objects.filter(authors__name=F("blog__name"))

	For date and datetime fields, you can add or subtract a *timedelta* object.
	e.g.:
	>>> from datetime import timedelta
	>>> Entry.objects.filter(mod_date__gt=F('pub_date')+timedelta(days=3))
*** the *pk* lookup shortcut
	For convenience, Django provides a *pk* lookup shortcut, which stands for
	"primary key".
*** Caching and QuerySets
	Each *QuerySet* contains a cache to minimize database access. 由于 Django 只
	有在触发查询 *QuerySet* 时才会查询数据库，故若想获得 Cache，必须先处罚相应的
	查询动作。

	e.g.:
	>>> queryset = Entry.objects.all()
	>>> print queryset[5]    # Queries the database
	>>> print queryset[5]    # Queries the database again

	If the entire queryset has already been evaluated, the cache will be
	checked.
	e.g.:
	>>> queryset = Entry.objects.all()
	>>> [entry for entry in queryset]    # Queries the database
	>>> print queryset[5]    # Uses cache
	>>> print queryset[5]    # Uses cache

	There are some actions that will result in the entire queryset being
	evaluated and therefore populate the cache:
	>>> [entry for entry in queryset]
	>>> bool(queryset)
	>>> entry in queryset
	>>> list(queryset)

	Note:
	+ Simply printing the queryset will not populate the cache. This is because
      the call to *__repr__()* only returns a slice of the entire queryset.
*** Comparing objects
	To compare two model instances, just use the standard Python comparison
	operator, the double equals sign. Behind the scenes, that compares the
	primary key values of two models.

	e.g.:
	>>> some_obj == other_obj
*** Deleting objects
	The delete method, conveniently, is named *delete()*. This method
	immediately deletes the object and has not return value.
	
	You can also delete objects in bulk. Every *QuerySet* has a *delete()*
	method, which deletes all members of that *QuerySet*.

	e.g.:
	>>> e.delete()
	>>> Entry.objects.filter(pub_date__year=2005).delete()
*** Updating multiple objects at once
	e.g.:
	>>> Entry.objects.filter(pub_date__year=2007).update(headline="Everything is
	    the same")
** Model inheritance
*** 概述
	There're three styles of inheritance that are possible in Django:
	  + Often, you will just want to use the parent class to hold information
        that you don't want to have to type out for each child model. This
        class isn't going to ever be used in isolation, so *Abstract base
        classes* are what your're after
	  + If you're subclassing an existing model (perhaps somthing from another
        application entirely) and want each model to have its own database
        table, *Multi-table inheritance* is the way to go
	  + If you only want to modify the Python-level behavior of a model,
        without changing the models fields in any way, you can use *Proxy
        models*
*** Abstract base classes
	+ 基础
	  即定义一个包含其它类公共信息的类，这个类不参与数据库建表，其它参与建表的
      model 继承自该类.该抽象类不能被当作一般的 model 被使用.该抽象类中需要定
      义 *class Meta* 的参数包含 *abstract=True*
	+ e.g.:
	  class CommonInfo(models.Model):
	      name = models.CharField(max_length=100)
	      age = models.PositiveIntegerField()

	      class Meta:
	          abstract = True

	  class Student(CommonInfo):
	      home_group = models.CharField(max_length=5)
	+ Meta inheritance
	  When an abstract base class is created, Django makes any *Meta* inner
      class you declared in the base class available as an attribute. If a
      child class doesn't declare its own *Meta* class, it will inherit the
      parent's *Meta*. If the child wants to extend the parent's *Meta* class,
      it can subclass it. If the child doesn't want one of attributes of *Meta*
      class to be effective, it can set the attribute as *''* in its own *Meta*
      class.
	+ e.g.:
	  class CommonInfo(models.Model):
	      ...
	      class Meta:
	          abstract = True
	          ordering = ['name',]

	  class Student(CommonInfo):
	      ...
          class Meta(CommonInfo.Meta):
	          db_table = 'student_table'
	          ordering = []
*** Multi-table inheritance
	即一个 model 可以继承自另一个 model，被继承的 model 也参与数据库建表.
*** Proxy models (不太理解)
	When using *multi-table inheritance*, a new database table is created for
	each subclass of a model. This is usually the desired behavior, since the
	subclass needs a place to store any additional data fields that are not
	present on the base class. Sometimes, however, you only want to change the
	Python behavior of a model -- perhaps to change the default manager, or add
	a new method.

	This is what proxy model inheritance is for: creating a proxy for the
	original model. You can create, delete and update instances of the proxy
	model and all the data will be saved as if you were using the original
	(non-proxied) model. The differene is that you can change things like the
	default model ordering or the default manager in the proxy, without having
	to alter the original.

	Proxy models are declared like normal models. You tell Django that it's a
	proxy model by setting *proxy=True* in the *Meta* class.
*** Ref
	+
      [[https://docs.djangoproject.com/en/1.5/topics/db/models/#model-inheritance][Model
     inheritance]]
** Performing raw SQL queries
*** use *Manager.raw()*
	Using this method is to perform raw queries and return model instances.
	This method takes a raw SQL query, executes it, and returns a 
	*django.db.models.query.RawQuerySet* instance. This *RawQuerySet* instance
	can be iterated over just like an normal *QuerySet* to provide object
	instances. 

	e.g.:
	
	class Person(models.Model):
	    firstname = models.CharField(max_length=10)
		lastname = models.CharField(max_length=10)

	>>> for p in Person.objects.raw("SELECT * FROM myapp_person"):
	...     print(p)
*** avoid the model layer entirely
	*django.db.connection* -- the default database connection
	*django.db.transaction* -- the default database transaction

	To use the database connection, call *connection.cursor()* to get a cursor
	objects. Then, call *cursor.execute(sql[, params])* to execute the SQL and 
	*cursor.fetchone()* or *cursor.fetchall()* to return the resulting rows.
	After performing a data changing operations, you should then call 
	*transaction.commit_unless_managed()* to ensure your changes are commited
	to the database. If your query is purely a data retrieval operation, no
	commit is required.

	e.g.:
	
	def my_custom_sql():
	    from django.db import connection, transaction

		cursor = connection.cursor()
		
		# Data modifying operation -- commit required
		cursor.execute("UPDATE bar SET foo=1 WHERE baz=%s", [self.baz,])
		transaction.commit_unless_managed()

		# Data retrieval operation -- no commit required
		cursor.execute("SELECT foo FROM bar WHERE baz=%s", [self.baz,])
		row = cursor.fetchone()

		return row
** 典型的数据库设计
*** blog
	class Blog(models.Model):
	    name = models.CharField(max_length=100)
		tagline = models.TextField()

		def __unicode__(self):
		    return self.name

	class Author(models.Model):
	    name = models.CharField(max_length=50)
		email = models.EmailField()

		def __unicode__():
		    return self.name

	class Entry(models.Model):
	    blog = models.ForeignKey(Blog)
		headline = models.CharField(max_length=255)
		body_text = models.TextField()
		# 我觉得 pub_date = models.DateField(auto_now=True) 更合适
		pub_date = models.DateField()
		# 我觉得 mod_date = models.DateField(auto_now_add=True) 更合适
		mod_date = models.DateField()
		authors = models.ManyToManyField(Author)
		n_comments = models.IntegerField()
		n_pingbacks = models.IntegerField()
		rating = models.IntegerField()
		
		def __unicode__(self):
		    return self.headline
** Note:
   + Django database layer is merely an interface to your database. You can
     access your database via other tools, programming language or database
     frameworks; there's nothing Django-specific about your database.
* View
** 功能.
   A view is a callable which takes a request and returns a response.
** function-based views
** class-based views
*** 概述
	Allow you to structure your views and reuse code by harnessing inheritance
	and mixins.

	All views inherit from the *View* class, which handles 
	  + linking the view in the URLs
      + HTTP method dispatching
      + other simple features.

	重要的 method:
	+ class.as_view(*initkwargs*)
	  Returns a callable view that takes a request and returns a response.

	  Any arguments passed to *as_view* will override attributes set on the
      class.

	  It servers as the callable entry point to your class. The *as_view()*
      entry point creates an instance of your class and calls its *dispatch()*
      method. *dispatch()* looks at the request to determine whether it is a
      GET, POST, etc, and relays the request to a matching method if one is
      defined, or raises *HttpResponseNotAllowed* if not.

	  返回的是 HttpResponse object.
*** 与 function-based views 对比优势
	Class-based views do not replace function-based views, but have advantages:
	+ Organization of code related to specific HTTP methods (GET, POST, etc.)
      can be addressed by separate methods instead of conditional branching.
	+ Object oriented techniques such as mixins (multiple inheritance) can be
      used to factor code into reusable components.
*** 两种使用方法
	+ simple usage in your URLconf
	  直接在 url 配置文件中使用三个基本的 view class.
	+ subclassing generic views
	  在 view 文件中写个继承自 view class 的 class，然后在 url 配置中使用该
      class.
*** 三个基础 View Class
	+ *View*
	  class django.views.generic.base.View
	  
	  The master class-based base view. All other class-based views inherit
      from this base class.
	+ *TemplateView*
	  class django.views.generic.base.TemplateView
	  
	  Renders a given template, with the context containing parameters captured
      in the URL.
    + *RedirectView*
	  class django.views.generic.base.RedirectView
	  
	  Redirects to a given URL.
*** Note
	+ You can only inherit from one generic view -- that is, only on parent
      class may inherit from *View* and the rest (if any) should be
      mixins. Trying to inherit from more than one class that inherits
      from *View* won't work as expected.
** generic class-based views
*** 概述
	本质上也是 class-based views，只是把 web 开发过程中使用 class-based views 时
	的一些共性抽象出来，形成可以完成一类任务的 class-based views.

	如果使用 generic views 过程中发现逻辑上处理越来越困难，可重新选择
	function-based views 或 class-based views.
*** class attributes
	+ model
	  指示使用的 model
	+ queryset
	  作用和 *model* 参数一样，指明该 view 处理的 data objects.但它可提供
      比 *model* 参数灵活的方法，如只获取指定的 data objects.

	  e.g.

	  from django.views.generic import DetailView, ListView
	  from books.models import Publisher, Book

	  class PublisherDetail(DetailView):
	      queryset				= Publisher.objects.all()
	      context_object_name	= 'publisher'

	  class BookList(ListView):
	      queryset				= Book.objects.order_by('-publication_date')
	      context_object_name	= 'book_list'

	  class AcmeBookList(ListView):
	      queryset				= Book.objects.filter(publisher__name='Acme Publishing')
	      context_object_name	= 'book_list'
	      template_name			= 'books/acme_list.html'
	+ context_object_name
	  定义模板中使用的与 model 数据相关的名称，修改 generic views 默认的名称 (如
      *ListView* 的派生类会默认使用 *object_list* 或 *model名的小写_list* 作为传
      给 template 的参数)，使可读性更强.
	+ template_name
	  指定使用的 template 名称，虽然 generic class-based views 可以根据一个
      model 来猜测使用的 template 名称，但最好显示指出.
*** object methods
	+ get_context_data(self, **kwargs)
	  - e.g.
		
	    class PublisherDetail(DetailView):
	        model = Publisher

            def get_context_data(self, **kwargs):
	            # call the base implementaion first to get a context
	            context = super(PublisherDetail, self).get_context_data(**kwargs)
	            # Add in a QuerySet of all the books
                context['book_list'] = Book.objects.all()

	            return context
	  - Note
		Generally, *get_context_data* will merge the context data of all parent
        classes with those of the current class. To preserve this behavior in
        your own classes where you want to alter the *context* , you sould be
        sure to call *get_context_data* on the super class. When no two classes
        try to define the same key, this will give the expected
        results. However, if any class attempts to override a key after parent
        classes have set it (after the call to *super*), any children of that
        class will also need to explictly set it after *super* if they want to
        be sure to override all parents.
    + get_queryset()
	  - 作用
		类似 *model* 和 *queryset* 参数，获取该 view class 要处理的 data
        objects.
	  - e.g.
		# urls.py
		from books.views import PublisherBookList

		urlpatterns = patterns('',
		  (r'^books/([\w-]+/$)', PublisherBookList.as_view())
	    )

		# views.py
		from django.shortcuts import get_object_or_404
		from django.views.generic import ListView
		from books.models import Book, Publisher

		class PublisherBookList(ListView):
		    template_name = "books/books_by_publisher.html"
		
		    def get_queryset(self):
		        self.publisher = get_object_or_404(Publisher, name=self.args[0])
		        
		        return Book.objects.filter(publisher=self.publisher)
    + get_object()
	  - 作用
	    It will do some extra work before calling the generic view.
	  - e.g.
		# models.py
		class Author(models.Model):
		    salutation			= models.CharField(max_length=10)
		    name				= models.CharField(max_length=200)
		    email				= models.EmailField()
		    headshot			= models.ImageField(upload_to='autho_headshots')
		    last_accessed		= models.DateTimeField()

		# urls.py
		from books.views import AuthorDetailView

		urlpatterns = patterns('',
		    url(r'^authors/(?P<pk>\d+)/$', AuthorDetailView.as_view()),
	    )

		# views.py
		from django.views.generic import DetailView
		from django.shortcuts import get_object_or_404
		from django.utils import timezone
		from books.models import Author

		class AuthorDetailView(DetailView):
		    queryset = Author.objects.all()
		
		    def get_object(self):
		        # call the superclass
		        object = super(AuthorDetailView, self).get_object()
		        # Record the last accessed date
		        object.last_accessed = timezone.now()
		        object.save()

		        return object
*** generic display views
**** DetailView (working with a single Django object)
	 class django.views.generic.detail.DetailView

	 While this view is executing, *self.object* will contain the object that
	 the view is operating upon.

	 To show the detail of an object, we basically need to do two things:
	   1) look up the object and then,
	   2) make a *TemplateResponse* with a suitable template, and that object
          as context
		  
     To get the object, *DetailView* relies on *SingleObjectMixin*, which
     provides a *get_object* method that figures out the object based on the
     URL of the request (it looks for *pk* and *slug* keyword arguments as
     declared in the URLConf, and looks the object up either from *model*
     attribute on the view, or the *queryset* attribute if that's
     provided). *SingleObjectMixin* also overrides *get_context_data()* , which
     is used across all Django's built in class-based views to supply context
     data for template renders.
**** ListView (working with many Django objects)
	 class django.views.generic.list.ListView

	 While this view is executing, *self.object_list* will contain the list of
	 obejcts (usually, but not necessarily a queryset) that the view is
	 operating upon.

	 The rough work flowchart of *ListView* is:
	   1) we need a (possibly paginated) list of objects, typically
          a *QuerySet*, then
	   2) we need to make a *TemplateResponse* with a suitable template using
          that list of objects.

	 To get the objects, *ListView* uses *MultipleObjectMixin*, which provides
	 both *get_queryset()* and *paginate_queryset()*. Unlike
	 with *SingleObjectMixin*, there's no need to key off parts of the URL to
	 figure out the queryset to work with, so the default just uses
	 the *queryset* or *model* attribute on the view class. A common reason to
	 override *get_queryset()* here would be dynamically vary the objects, such
	 as depending on the current user or to exclude posts in the future for a
	 blog.

	 *MultipleObjectMixin* also overrides *get_context_data()* to include
	 appropriate context variables for pagination (providing dummies if
	 pagination is disabled). It relies on *object_list* being passed in as a
	 keyword argument, which *ListView* arranges for it.
**** Ref
	 + [[https://docs.djangoproject.com/en/1.5/ref/class-based-views/generic-display/][django1.5文档]] 不太理解
     + [[https://docs.djangoproject.com/en/1.5/topics/class-based-views/mixins/][Using mixins with class-based views]]
*** Ref
	+
      [[https://docs.djangoproject.com/en/1.5/topics/class-based-views/mixins/][Using mixins with class-based views]]
* Template
** 综述
   A template is simply a text file. It can generate any text-based format
   (HTML, XML, CSV, etc.)

   A template contains two components:
   + *variables*
	 They will get replaced with values when the template is evaluated.
   + *tags*
	 They will control the logic of the template
** Variables
   Variables look like this: {{variable}}
   When the template engine encounters a variable, it evaluates that variable
   and replace it with the result.

   When the template system encounters a dot, it tries the following lookups,
   in this order:
   1) Dictionary lookup
   2) Attribute lookup
   3) Method call
   4) List-index lookup

   Note:
   + 变量不存在时
     If you use a variable that doesn't exist, the template system will insert
     the value of *TEMPLATE_STRING_IF_INVALID* setting, which is set to '' (the
     empty string) by default.
   + 整体替换
	 Note that "bar" in a template expression like {{foo.bar}} will be
     interpreted as a literal string and not using the value of the variable
     "bar", if one exists in the template context.
** Filters
   The purpose of filters is to modify variables.
   
   Some types of filters:
   + {{name | lower}}
	 The most common style.
   + {{text | escaped | linebreaks}}
	 Filters can be "chained".
   + {{bio | truncatewords:30}}
	 Some filters take arguments.
   + {{list | join:", "}}
	 Filter arguments that contain spaces must be quoted.

   Some filters used frequently:
   + default
	 If a variable is false or empty, use given default. Otherwise, use the
     value of the variable.

	 e.g.:
	   {{value | default:"nothing"}}
   + length
	 Returns the length of the value. This works for both strings and lists.
	 
	 e.g.:
	   {{value | length}}
   + striptags
	 Strips all [X]HTML tags.

	 e.g.:
	   {{value | striptagse}}
	   If _value_ is "<b>Joel</b> <button>is</button> a <span>slug</span>", the
       output will be "Joel is a splug".
** Tags
   Tags look like this: {% tag %}
 
   Functionalities of tags:
   + some create text in the output
   + some control flow by performing loops or logic
   + some load external information into the template to be used by later
     variables
   + some tags require beginning and ending tags 
     (i.e. {% tag %} ... tag content ... {% endtag %})
	 
   Some tags used frequently:
   + *for*
	 Loop over each item in an array.

	 e.g.:
	 <ul>
	 {% for athlete in athelete_list %}
	   <li>{{athlete.name}}</li>
	 {% endfor %}
     </ul>
   + *if* and *else*
	 Evaluate a variable, and if that variable is "true", the contents of the
     block are displayed.

	 e.g.:
	 {% if athelete_list %}
	   Number of athlete: {{athelete_list | length}}
	 {% else %}
	   No athletes.
	 {% endif %}
	 
	 {% if athelete_list|length > 1 %}
	   Team: {% for athlete in athelete_list %} ... {% endfor %}
	 {% else %}
	   Athlete: {{athelete_list.0.name}}
     {% endif %}
   + *block* and *extends*
	 Set up template inheritance, a powerful way of cutting down
     on "boilerplate" in templates.
** Comments
   To comment-out part of a line in a template, use the comment syntax: *{# #}*
   
   This syntax can only be used for single-line comments.
** Template inheritance
   A simple example:
   # base.html
   <html lang="en">
     <head>
	   <link rel="stylesheet" href="style.css" />
	   <title>{% block title %}My amazing site{% endblock %}</title>
	 </head>

	 <body>
	   <div id="sidebar">
	     {% block sidebar %}
		   <ul>
		     <li><a href="/">Home</a></li>
			 <li><a href="/blog/">Blog</a></li>
		   </ul>
		 {% endblock%}
	   </div>

	   <div id="content">
	     {% block content %}{% endblock%}
	   </div>
	 </body>
   </html>

   # another html file
   {% extends "base.html" %}
   
   {% block title %}My amazing blog{% endblock%}

   {% block content %}
     {% for entry in blog_entires %}
	   <h2>{{entry.title}}</h2>
	   <p>{{entry.body}}</p>
	 {% endfor %}
   {% endblock%}


   You can use as many levels of inheritance as needed.
   
   BEST PRACTICE:
   1) Create a *base.html* template that holds the main look-and-feel of your
      site.
   2) Create a *base_SECTIONNAME.html* template for each "section" of your
      site. For example, *base_news.html*, *base_sports.html*. These templates
      all extend *base.html* and include section-specific styles/design.
   3) Create individual templates for each type of page, such as a news article
      or blog entry. These templates extend the appropriate section template.

   Here are some tips for working with inheritance:
   + If you use *{% extends %}* in a template, it must be the first template
     tag in that template. Template inheritance won't work, otherwise.
   + More *{% block %}* tags in your base templates are better. Child templates
     don't have to define all parent blocks, so you can fill in reasonalbe
     defaults in a number of blocks, then only define the ones you need later.
   + If you find youself duplicating content in a number of templates, it
     probably means you should move that content to a *{% block %}* in a parent
     template.
   + If you need to get the content of the block from the parent template,
     the *{{block.super}}* variable will do the trick. This is useful if you
     want to add to the contents of a parent block instead of completely
     overriding it. Data inserted using *{{block.super}}* will not be
     automatically escaped, since it was already escaped, if necessary, in the
     parent template.
   + For extra readbility, you can optionally give a name to your 
     *{% endblock %}* tag.

	 e.g.:
	 {% block content %}
	 ...
	 {% endblock content %}
** Automatic HTML escaping
   User-submitted data shouldn't be trusted blindly and inserted directly into
   your web pages, because a malicious user could use this kind of hole to do
   potentially bad things.
   This type of security exploit is called a *Cross Site Scripting (XSS)*
   attack.
   But if you're using Django's template system, you're protected.

   By default in Django, every template automatically escapes the output of
   every variable tag.
   Specifically, these five characters are escaped:
   1) *<* is converted to *&lt;*
   2) *>* is converted to *&gt;*
   3) *'* (single quote) is converted to *&#39;*
   4) *"* (double quote) is converted to *&quot;*
   5) *&* is converted to *&amp;*

   Conditions that you may want to turn the auto-escaping off:
   1) Sometimes, template variables contain data that you intend to be rendered
      as raw HTML, in which case you don't want their contents to be
      escaped. For example, you might store a blob of HTML in your database and
      want to embed that directly into your template.
   2) you might using Django's template system to produce text that is not HTML
      -- like an email message, for instance.

   Method to turn off the auto-escaping functionality:
   1) For individual variables
	  To disable auto-escaping for an individual variable, use the *safe*
      filter.

	  e.g.:
	  This will not be escaped: {{data | safe}}
   2) For template blocks
	  To control auto-escaping for a template, wrap the template (or just a
      particular section of the template) in the *autoescape* tag.

	  e.g.

	  Auto-escaping is on by default. Hello {{name}}
	  {% autoescape off %}
	    This will not be auto-escaped: {{data}}

	    {% autoescape on %}
	      Auto-escaping applies again: {{name}}
        {% endautoescape %}
	  {% endautoescape %}

   Note:
   + The auto-escaping tag passes its effect onto templates that extend the
     current ones as well as templates included via the *include* tag, just
     like all block tags.即，若使用 *{% autoescape %}{% endescape %}* 时，会被继
     承它的模板继承相同的作用。
** Custom tag and filter libraries
   Certain applications provide custom tag and filter libraries. To access them
   in a template, ues the *load* tag:

   e.g.:
   {% load comments %}
   
   ...

   The *load* tag can take multiple library names, separated by spaces.

   e.g.:
   {% load comments i18n%}
* Form
** 包含 4 种概念
   + Widget
	 A class that corresponds to an HTML form widget, e.g. <input type='text'>
     or <textarea>. This handles rendering of the widgets as HTML.
   + Field
	 A class that is responsible for doing validation, e.g. an 'EmailField'
     that makes sure its data is a valid email address.
   + Form
	 A collection of fields that knowns how to validate itself and display
     itself as HTML.
   + Form Media
	 The CSS and JavaScript resources that are required to render a form.
** 常规需要处理的 3 种类型
   + Initial GET (blank or prepolulated form)
   + POST with invalid data (typically redisplay form with errors)
   + POST with valid data (process the data and typically redirect)
** 可通过 class-based views 实现
*** Basic Usage
	# forms.py
	from django import forms
	
	class ContactForm(forms.Form):
	    name	= forms.CharField()
		message = forms.CharField(widget=forms.Textarea)

		def send_email(self):
		    # send email using the *self.cleaned_data* dict
		    pass

	# views.py
	from myapp.forms import ContactForm
	from django.views.generic.edit import FormView

	class ContactView(FormView):
	    template_name	= 'contact.html'
		form_class		= ContactForm
		successful_url	= '/thanks/'

		def form_valid(self, form):
		    # This method is called when valid form data has been POSTed
		    # The default implementation for *form_valid()* simply redirects
		    # to the *successful_url*
		    # It should return an *HttpResponse*
		    form.send_email()
			return super(ContactForm, self).form_valid(form)
*** Model Forms
	+ 概述
	  The following generic views will automatically create a *ModelForm*, so
      long as they can work out which model class to use:
	  1) If the *model* attribute is given, that model class will be used
	  2) if *get_object()* returns an object, the class of that object will be
         used.
      3) If a *queryset* is given, the model for that queryset will be used.

	  Model form views provide a *form_valid()* implementation that saves the
      model automatically.

	  You don't need to provide a *successful_url* for *CreateView*
      or *UpdateView* -- they will use *get_absolute_url()* on the model object
      if available.

	  If you want to use a custom *ModelForm* (for instance to add extra
      validation), simply set *form_class* attribute on your view. At the same
      time, you must specify the model.
	+ e.g.
	  # models.py
	  from django.core.urlresolvers import reverse
	  form django.db import models

	  class Author(models.Model):
	      name = models.CharField(max_length=200)

	      def get_absolute_url(self):
	          return reverse('author-detail', kwargs={'pk': self.pk,})

	  # views.py
	  from django.views.generic.edit import CreateView, UpdateView, DeleteView
	  from django.core.urlresolves import reverse_lazy
	  from myapp.models import Author

	  class AuthorCreate(CreateView):
	      model			= Author
	      template_name = 'some_template'

	  class AuthorUpdate(UpdateView):
	      model			= Author
	      template_name = 'some_template'

	  class AuthorDelete(DeleteView):
	      model					= Author
	      successful_url		= reverse_lazy('autho-list')
	      template_name			= 'some_template'

	  # urls.py
	  from django.conf.urls import patterns, url
	  from myapp.views import AuthorCreate, AuthorUpdate, AuthorDelete

	  urlpatterns = patterns('',
	      url(r'author/add/$', AuthorCreate.as_view(), name='author_add'),
	      url(r'author/(?P<pk>\d+)/$', AuthorUpdate.as_view(),
              name='author_update'),
	      url(r'author/(?P<pk>\d+)/delete/$', AuthorDelete.as_view(), 
	          name='author_delete'),
	  )
*** Ref
	+ [[https://docs.djangoproject.com/en/1.5/topics/class-based-views/generic-editing/][Form handling with class-based views]]
* 测试
** TDD (Test Driven Development)
   先写测试后写代码，思维过程是 "描述问题-->解决问题".
** 执行
   在 app 的根目录下写完 tests.py 后，在项目的根目录下执行:
   $ python manage.py test app名
** best practice
   + a separate *TestCase* for each model or view
   + a separate test method for each set of conditions you want to test
   + test method names that describe their function
* 部署
** nginx+uwsgi
*** 安装 uwsgi
	$ sudo pip install uwsgi
	
	Note:
	+ 通过 pip 安装，最好不要直接通过系统的包管理器安装，可能会有问题.
*** 测试 uwsgi
	编写 test.py
	
	# test.py
	def application(env, start_response):
	    start_response('200 OK', [('Content-Type', 'text/html')])
		return 'Hello World'

	执行:
	$ uwsgi --http :8001 --wsgi-file test.py
	通过 http://127.0.0.1:8001 访问网页是否有 'Hello World'
*** 仅通过 uwsgi 部署 django
	$ django_admin.py startproject 项目名

	在该项目根目录下添加 django_wsgi.py 文件，

	# django_wsgi.py
	#!/usr/bin/python2.7
	# coding:utf-8

	import os
	import sys
	
	os.environ.setdefault("DJANGO_SETTINGS_MODULE", "项目名.settings")
	
	from django.core.handlers.wsgi import WSGIHandler
	
	application = WSGIHandler()

	部署项目:
	$ uwsgi --http :8000 --chdir /PATH/TO/项目 --module django_wsgi
	把 '/PATH/TO/项目' 改为项目地址，如 '/home/flyer/Practice/项目名'
	通过 http://127.0.0.1:8000 访问项目.
*** 通过 nginx+uwsgi 部署 django
	nginx 处理静态文件，动态文件由 nginx 交给 uwsgi 处理，二者通过 socket 通信.
	假设项目地址 '/home/flyer/Practice/项目名'，nginx 通过 8077 端口与 uwsgi 通信,
	在 '/home/flyer/Practice/项目名/' 根目录下创建 django_wsgi.py(内容同上) 和
	django_socket.xml 文件:

	# django_socket.xml
	<uwsgi>
	    <socket>:8077</socket>
		<chdir>/home/flyer/Practice/项目名/</chdir>
		<module>django_wsgi</module>
		<processes>django_wsgi</processes>
		<daemonize>uwsgi.log</daemonize>
	</uwsgi>

	假设 access.log 和 error.log 放在 '/home/flyer/logs/nginx/' 中，项目中的静态
	文件在 '/home/flyer/Practice/项目/static/' 和 
	'/home/flyer/Practice/项目名/media/' 中，域名端口是 8060.
	修改 nginx.conf (不同的系统该文件地址不一样，搜一下):

	server {
	    listen 8060;
		server_name 域名(本机上可设置为 localhost);

		access_log /home/flyer/logs/nginx/access.log;
		error_log /home/flyer/logs/nginx/error.log;

		location / {
		    include uwsgi_params;
			uwsgi_pass 127.0.0.1:8077;
		}

		error_page 500 502 503 504 /50x.html;
		location = /50x.html {
		    root html;
		}

		location /static/ {
		    alias /home/flyer/Practice/项目/static/;
			index index.html index.htm;
		}

		location /media/ {
		    alias /home/flyer/Practice/项目/media/;
		}
	}

	先通过 
	# nginx -t
	检查下 nginx 配置的语法是否正确，若正确，重启下 nginx.
	启动 uwsgi 服务器:
	$ cd /home/flyer/Practice/项目/
	$ uwsgi -x django_socket.xml
	查看 uwsgi.log 文件是否异常，若无异常，通过 http://域名:8060 访问项目
*** Refer
   http://django-china.cn/topic/101/
   http://django-china.cn/topic/124/
* 一些名词
** slug
   *Slug* is a newspaper term. 
   A slug is short label for something, containing only letters, numbers,
   underscores or hyphens. They're generally used in URLs.
** QuerySet
   A *QuerySet* represents a collection of objects from your database. It can
   have zero, one or many *filters*
* Tips & Best Practice
** views 中通过 render 向模板中传入 dict 类型数据
   views 中通过 model 获得的是一个 object，可通过如下类似方法把它转化为模板能正
   确处理的 dict 类型:

   # views.py 的某个 view 函数中
   profile		= SomeModel.object.get(some_condition).__dict__
   res			= {'profiles': profile}
   return render(request, 模板, res)

   模板中直接使用 dict 类型的 'profiles' 变量.
** 展示静态页面时用 TemplateView
   如在 urls.py 中配置

   from django.conf.urls import patterns, url
   from django.views.generic import TemplateView

   urlpatterns = patterns('',
       url(r'^about/', TemplateView.as_view(template_name="about.html"))
   )
** url 命名
   这样做是为了避免在 view 或 template 中 hardcode url 路径，这样对 url 的修改仅
   用在 url 的配置文件中进行.

   在主项目的 urls.py 中进行如下类似操作：

   urlpatterns = patterns('',
       url(r'url路径', include(app名.url, name='url名')),
   )

   然后在 app 的 urls.py 中进行如下类似操作：

   urlpatterns = patterns('',
       url(r'url路径', 相应的 view, name='app中url名')
   )

   在 template 中需要使用路径时，进行如下类似操作:

   <a href="{% url 'url名:app中url名' [传给app中url的参数] %}"></a>
