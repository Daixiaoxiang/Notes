* Overview
  Elasticsearch is a flexible and powerful open source, distributed, real-time
  search and analytics engine. 
  
  有个技术栈是:
  + elasticsearch
	- 提供分布式搜索服务.
	- real time data
	- real time analytics
	- distributed
	- high availability
	- multi-tenancy
	- full text search
	- document oriented
	- conflict management
	- schema free
	- restful api
	- per-operation persistence
	- build on top of apache lucene
  + logstash
	提供实时日志分析服务.
  + kibana
	提供数据可视化服务. 
* 搜索引擎结构
  + 搜索信息 (web crawling)
	爬虫爬取大量信息.
  + 整理信息 (indexing)
	建立索引, 便于快速查询.
  + 接受查询 (searching)
	根据用户的需求返回用户感兴趣的信息.
* 搜索引擎分类
  + 全文搜索引擎 (Full Text Search Engine)
	搜索并返回的是全文的信息
  + 垂直搜索引擎 (Vertical Search Engine)
	搜索某个领域的信息, 如图片、新闻等, 返回的结果可能只与该细分领域有关 
  + 元搜索引擎 (Meta Search Engine)
	结合多个搜索引擎的结果
* REST 查询选项
** 通用选项
   + pretty results
	 - 'pretty=true'  (for debugging only)
	   美化输出的 json 格式数据.
	 - 'format=yaml'
	   会通过 yaml 格式输出.
   + human readable output
	 可添加 'human=true' 形式使得输出 human-readable, 默认值是 false.
   + flat settings
	 The *flat_settings* flag affects rendering of the lists of settings.
** refer
   + [[http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/common-options.html][common options]]
   + [[http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/docs.html][document apis]]
* 索引 mongo 中的数据
** overview
   可参考 [[https://coderwall.com/p/sy1qcw][这篇文章]]
** 注意点
   + 要使用 mongo replica set
   + 安装 elasticsearch-river-mongodb 后需要重启 ES
   + 可通过 elasticsearch-river-head 查看 ES 建立的索引 
* API
** 添加索引和数据
** 删除索引
   如:
   $ curl -XDELETE 'http://localhost:9200/person'
** 删除数据
** 查询
* 索引
  ES 会对全文进行索引.
* 分词
  默认的中文分词是把切分每个中文字, 然后在文档中搜索这些字.
* 搜索分类
  + 搜索某个具体的字段 (精确搜索)
	a structured query on concrete fields like *gender* or *age* , sorted by
    *join_date* , similar to a query that you could construct in SQL.
  + 搜索全文中的某个词 (模糊搜索)
	a full text query, which finds all documents matching the search keywords,
    and returns them sorted by relevance.
  + 以上两者的结合
    or a combination of the two.
* 与搜索相关的三个主题
** Mapping (如何进行索引)
   How the data in each field is interpreted.

   查看 mapping, 如
   $ curl 'http://localhost:9200/twitter/_mapping/tweet'
** Analysis (对查询语句进行分词)
   How full text is processed to make it searchable.
** Query DSL (查询的规则)
   The flexible, powerful query language used by ES.
* 一些特殊变量
** 用于查询方面的
*** _all
   表示所有信息, 如
   + curl -XGET 'http://localhost:9200/_all/_search=referer:"http://www.baidu.com"'
	 查询所有的索引 
   + curl -XGET 'http://localhost:9200/twitter/_all/_search=refer:"http://www.baidu.com"'
	 查询索引名为 'twitter' 的所有类型的文档
*** _search
   在 HTTP API 中表示查询条件.
*** explain
	对查询过程进行解释. 
** 用于解释方面的
*** _index
	表征索引名
*** _type
	表征类型名 
*** _id
	在该 index 和 type 下唯一表征该文档.
*** _shard
	表征分片. 
*** _node
	表征所在的节点. 
*** _score
   在 full-text search 中, 用来表征相关性的强弱, 它是根据具体的查询条件计算出来
   的.
   详情可查看 [[http://www.elasticsearch.org/guide/en/elasticsearch/guide/current/relevance-intro.html][这篇文章]].
*** _explanation
	对查询进行解释
*** _source
	文档的具体内容.
* 一些特殊的查询条件
** bool 查询
   通过 '+'、'-' 和 'not' 来表示.
* 需要深入的 plugins
  + elasticsearch-mapper-attachment
  + elasticsearch-river-mongodb
* 名词解释
** mapper
   与建索引有关.
** analysis
   与查询时的分词有关.
** river
   数据源
** transport
   使用 ES 的方式.
** gateway (???)
   The gateway allows for persisting the cluster state between full cluster
   restarts. Every change to the state (such as adding an index) will be stored
   in the gateway, and when the cluster starts up for the first time, it will
   read its state from the gateway.
** 官方的文档
   [[http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/_basic_concepts.html][basic concepts]]
   
   + near realtime (nrt)
	 Elasticsearch is a near real time search platform. What this means is a
     slight latency (normally 1 second) from the time you index a document
     until the time it becomes searchable.
   + cluster
	 A cluster is a collection of one or more nodes (servers) that together
     holds your entire data and provides federated indexing and search
     capabilities across all nodes. A cluster is identified by a unique name
     which by default is "elasticsearch". This name is important because a node
     can only be part of cluster if the node is set up to join the cluster by
     its name. It is a good practice to explicitly set the cluster name in
     production, but it is fine to use the default for testing/development purposes.
   + node
	 A node is a single server that is part of your cluster, stores your data,
     and participates in the cluster's indexing and search capabilities. 
	 Just like a cluster, a node is identified by a name which by default is a
     random Marvel character name that is assigned to the node at startup.
	 A node can be configured to join a specific cluster by the cluster
     name. By default, each node is set up to join a cluster
     named *"elasticsearch"* which means that if you start up a number of nodes
     on your network and assuming they can discover each other, they will
     automatically form and join a single cluster named *"elasticsearch."*.
   + index
	 An index is a collection of documents that have somewhat similar
     characteristics.
	 An index is identified by a name (*that must be all lowercase*) and this
     name is used to refer to the index when performing indexing, search,
     update, and delete operations against the documents in it .

	 In a single cluster, you can define as many indexes as you want.
   + type
	 Within an index, you can define one or more types. A type is a logical
     category/partition of your index whose semantics is completely up to
     you. In general, a type is defined for documents that have a set of common
     fields.
   + document
	 A document is a basic unit of information that can be indexed. This
     document is expressed in JSON.
	 
	 Within an index/type, you can store as many documents as you want. Note
     that although a document physically resides in an index, a document
     actually must be indexed/assigned to a type inside an index.
   + shards & replicas
	 An index can potentially store a large amount of data that can exceed the
     hardware limits of a single node.
	 To solve this problem, Elasticsearch provides the ability to subdivide
     your index into multiple pieces called shards. When you create an index,
     you can simply define the number of shards that you want. Each shard is in
     itself a fully-funcitonal and independent "index" that can be hosted on
     any node in the cluster.
	 
	 Sharding is important for two primary reasons:
	 - It allows you to horizontally split/scale your content volume
	 - It allows you distribute and paralleize operations across shards
       (potentially on multiple nodes) thus increasing performance/throughput.

     The mechanics of how a shard is distributed and also how its documents
     are aggregated back into search requests are completely managed by
     Elasticsearch and is transparent to you as the user.

	 In a network/cloud environment where failures can be expected anytime, it
     is very useful and highly recommended to have a failover mechanism in case
     a shard/node somehow goes offline or disappears for whatever reason. To
     this end, Elasticsearch allows you to make one or more copies of your
     index’s shards into what are called replica shards, or replicas for short.

     Replication is important for two primary reasons:
	 - It provides high availability in case a shard/node fails. For this
       reason, it is important to note that a replica shard is never allocated
       on the same node as the original/primary shard that it was copied from.
	 - It allows you to scale out your search volume/throughput since searches
       can be executed on all replicas in parallel.

     To summarize, each index can be split into multiple shards. An index can
     also be replicated zero (meaning no replicas) or more times. Once
     replicated, each index will have primary shards (the original shards that
     were replicated from) and replica shards (the copies of the primary
     shards). The number of shards and replicas can be defined per index at the
     time the index is created. After the index is created, you may change the
     number of replicas dynamically anytime but you cannot change the number
     shards after-the-fact.

	 By default, each index in Elasticsearch is allocated 5 primary shards and 1
     replica which means that if you have at least two nodes in your cluster,
     your index will have 5 primary shards and another 5 replica shards (1
     complete replica) for a total of 10 shards per index.
* FAQ
** index 含义
   对数据建立索引, 是抽取出数据中的关键词汇, 然后建立这些词汇和数据的映射关系,
   便于根据关键词快速查找相关数据. 
** doc_type 含义
   不同类型的数据有不同的类型, 如 html、png、text 等，通过指明 doc_type 可以缩小
   在 index 查找的范围.
** id 含义
   精确查找某个 index 中某个 doc_type 中的 id 为多少的一个数据. 
** 精确查找
   根据 index 中的数据的具体字段进行精确查询, 不涉及到结果返回的相关性和评分问题.
** 模糊查找
   根据关键词进行全文查询. 
** 什么是 "单文档查找"
** 什么是 "多文档查找"
** ES 如何建立索引
   In Elasticsearch, all data in every field is indexed by default.That is,
   every field has a dedicated inverted index for fast retrieval. And, unlike
   most other databases, it can use all of those inverted indices in the same
   query, to return results at breathtaking speed.

   Every field in a document is indexed and can be queried. 

   即 ES 对全文进行索引.
** ES 如何处理中文分词
   自带的中文分词是把搜索词拆分成一个个中文字, 然后匹配这些字.
** ES 如何处理搜索条件
   通过 DSL，可查看
   [[http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl.html][query
   dsl]] 、
   [[http://okfnlabs.org/blog/2013/07/01/elasticsearch-query-tutorial.html#query-dsl-overview][elasticsearch-query-tutorial]]
   和
   [[https://github.com/elasticsearch/elasticsearch-py/blob/master/example/queries.py][queries.py]]
** ES 的插件机制是什么
** 如何使用 ES 分布式特性
** 直接使用二进制的 ES 和安装 ES 的差别在哪儿
** 默认搜索展示的数目
   默认只展示 10 个，可修改参数展示所有的结果.
** ES 中的 shard 和 replica 配置
   来自 ES 的 README.textile:

   By default, an index is created with 5 shards and 1 replica per shard
   (5/1). There are many topologies that can be used, including 1/10 (improve
   search performance), or 20/1 (improve indexing performance, with search
   executed in a map reduce fashion across shards).

   从上述中可以知道:
   + shard 多时，可以提高 index 性能
   + replica 多时，可以提高 search 性能 

   The rule of thumb is:
   + Having more *shards* enhances the _indexing_ performance and allows to
     _distribute_ a big index across machines.
   + Having more *replicas* enhances the _search_ performance and improves the
     cluster _availability_.

  NOTE:
  + The "number_of_shards" is a one-time setting for an index.
  + The "number_of_replicas" can be increased or decreased anytime, by using the
    Index Update Settings API.
** 如何查看集群状态
   如:
   $ curl -XGET http://localhost:9200/_cluster/health?pretty=true
** 如何查看索引状态
   如:
   $ curl -XGET http://localhost:9200/索引名/_status?pretty=true
* 常见问题
** 1.2 之后不再支持 Java1.6  
   可参考 [[http://www.elasticsearch.org/blog/elasticsearch-1-2-0-released/][这篇文档]]
** ES 对 ip:port 的使用
   Elasticsearch, by default, binds itself to the 0.0.0.0 address, and listens
   on port [9200-9300] for HTTP traffic and on port [9300-9400] for
   node-to-node communication. (the range means that if the port is busy, it
   will automatically try the next port).
** ES 的 http api 每个 {} 中的最后一项后面不要加 ','
* 影响 ES 性能的因素
** JVM swap
   Elasticsearch performs poorly when JVM starts swapping: you should ensure
   that it _never_ swaps.

   Make sure that the ES_MIN_MEM and ES_MAX_MEM environment variables are set to
   the same value, and that the machine has enough memory to allocate for
   Elasticsearch, leaving enough memory for the operating system itself.

   You should also make sure that the Elasticsearch process is allowed to lock
   the memory, eg. by using `ulimit -l unlimited`.
   
   RESOLVE:
   + (解决问题 1) 修改 ES 配置文件中的参数.
